<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="如何在移动应用程序开发中正确使用加密技术"><meta name="keywords" content="加解密,信息安全"><meta name="author" content="Andy"><meta name="copyright" content="Andy"><title>如何在移动应用程序开发中正确使用加密技术 | 移动安全星球</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.9.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.9.0"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.3.1/css/all.css?version=1.9.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  hexoVersion: '5.4.2'
} </script><meta name="generator" content="Hexo 5.4.2"></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-number">1.</span> <span class="toc-text">前言</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#KRACK%E6%94%BB%E5%87%BB"><span class="toc-number">1.1.</span> <span class="toc-text">KRACK攻击</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#WhatsApp%E8%BF%9C%E7%A8%8B%E6%89%A7%E8%A1%8C%E4%BB%A3%E7%A0%81%E6%BC%8F%E6%B4%9E"><span class="toc-number">1.2.</span> <span class="toc-text">WhatsApp远程执行代码漏洞</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Zoom%E5%8A%A0%E5%AF%86%E6%BC%8F%E6%B4%9E"><span class="toc-number">1.3.</span> <span class="toc-text">Zoom加密漏洞</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#COVID-19%E7%96%AB%E6%83%85%E7%9B%B8%E5%85%B3%E7%9A%84%E7%BD%91%E7%BB%9C%E6%94%BB%E5%87%BB"><span class="toc-number">1.4.</span> <span class="toc-text">COVID-19疫情相关的网络攻击</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Freak%E6%BC%8F%E6%B4%9E"><span class="toc-number">1.5.</span> <span class="toc-text">Freak漏洞</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%86%E7%A0%81%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">2.</span> <span class="toc-text">密码的作用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%9D%E8%AF%81%E4%BF%A1%E6%81%AF%E7%9A%84%E6%9C%BA%E5%AF%86%E6%80%A7"><span class="toc-number">2.1.</span> <span class="toc-text">保证信息的机密性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%9D%E8%AF%81%E4%BF%A1%E6%81%AF%E7%9A%84%E7%9C%9F%E5%AE%9E%E6%80%A7"><span class="toc-number">2.2.</span> <span class="toc-text">保证信息的真实性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%9D%E8%AF%81%E6%95%B0%E6%8D%AE%E7%9A%84%E5%AE%8C%E6%95%B4%E6%80%A7"><span class="toc-number">2.3.</span> <span class="toc-text">保证数据的完整性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%9D%E8%AF%81%E8%A1%8C%E4%B8%BA%E7%9A%84%E4%B8%8D%E5%8F%AF%E5%90%A6%E8%AE%A4%E6%80%A7"><span class="toc-number">2.4.</span> <span class="toc-text">保证行为的不可否认性</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%E4%BD%BF%E7%94%A8%E4%B8%8D%E5%BD%93%E5%AF%BC%E8%87%B4%E7%9A%84%E5%AE%89%E5%85%A8%E9%A3%8E%E9%99%A9"><span class="toc-number">3.</span> <span class="toc-text">加密算法使用不当导致的安全风险</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%9A%E4%BF%A1%E4%B8%AD%E5%AE%89%E5%85%A8%E6%80%A7%E5%A8%81%E8%83%81"><span class="toc-number">4.</span> <span class="toc-text">通信中安全性威胁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%86%E9%92%A5%E7%A1%AC%E7%BC%96%E7%A0%81%E9%A3%8E%E9%99%A9%E6%A1%88%E4%BE%8B"><span class="toc-number">5.</span> <span class="toc-text">密钥硬编码风险案例</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Android"><span class="toc-number">5.1.</span> <span class="toc-text">Android</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#iOS"><span class="toc-number">5.2.</span> <span class="toc-text">iOS</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Android-SDK%E6%8F%90%E4%BE%9B%E7%9A%84%E5%8A%A0%E5%AF%86%E7%9B%B8%E5%85%B3API"><span class="toc-number">6.</span> <span class="toc-text">Android SDK提供的加密相关API</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95%E4%B9%8B%EF%BC%9ABase64%E7%BC%96%E7%A0%81"><span class="toc-number">7.</span> <span class="toc-text">常用算法之：Base64编码</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%80%E5%8F%91%E8%80%85%E5%BB%BA%E8%AE%AE"><span class="toc-number">7.1.</span> <span class="toc-text">开发者建议</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95%E4%B9%8B%EF%BC%9A%E9%9A%8F%E6%9C%BA%E6%95%B0%E7%94%9F%E6%88%90%E5%99%A8"><span class="toc-number">8.</span> <span class="toc-text">常用算法之：随机数生成器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%80%E5%8F%91%E8%80%85%E5%BB%BA%E8%AE%AE-1"><span class="toc-number">8.1.</span> <span class="toc-text">开发者建议</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95%E4%B9%8B%EF%BC%9AHash%E7%AE%97%E6%B3%95"><span class="toc-number">9.</span> <span class="toc-text">常用算法之：Hash算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%B9%E7%82%B9"><span class="toc-number">9.1.</span> <span class="toc-text">特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%80%E5%8F%91%E8%80%85%E5%BB%BA%E8%AE%AE-2"><span class="toc-number">9.2.</span> <span class="toc-text">开发者建议</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E8%AE%A4%E8%AF%81%E7%AE%97%E6%B3%95"><span class="toc-number">10.</span> <span class="toc-text">消息认证算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%80%E5%8F%91%E8%80%85%E5%BB%BA%E8%AE%AE-3"><span class="toc-number">10.1.</span> <span class="toc-text">开发者建议</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95"><span class="toc-number">11.</span> <span class="toc-text">对称加密算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%80%E5%8F%91%E8%80%85%E5%BB%BA%E8%AE%AE-4"><span class="toc-number">11.1.</span> <span class="toc-text">开发者建议</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86"><span class="toc-number">12.</span> <span class="toc-text">非对称加密</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%80%E5%8F%91%E8%80%85%E5%BB%BA%E8%AE%AE-5"><span class="toc-number">12.1.</span> <span class="toc-text">开发者建议</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95PBE"><span class="toc-number">13.</span> <span class="toc-text">加密算法PBE</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">14.</span> <span class="toc-text">总结</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%A0%E6%9D%A1%E5%8E%9F%E5%88%99"><span class="toc-number">14.1.</span> <span class="toc-text">几条原则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%86%E9%92%A5%E5%AD%98%E5%82%A8%E5%AE%89%E5%85%A8%E6%80%A7%E4%BB%8E%E9%AB%98%E5%88%B0%E4%BD%8E"><span class="toc-number">14.2.</span> <span class="toc-text">密钥存储安全性从高到低</span></a></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://images.unsplash.com/photo-1649797044741-ea00a0bec0a3"></div><div class="author-info__name text-center">Andy</div><div class="author-info__description text-center">天生我材必有用</div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">11</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">28</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">10</span></a></div><hr><div class="author-info-links"><div class="author-info-links__title text-center">Links</div><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="https://cxf-boluo.github.io/">cxf-boluo</a><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="https://staticasd.github.io/">staticasd</a><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="https://www.freebuf.com/author/%E6%9A%97%E5%BD%B1%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C%E5%AE%A4">暗影安全实验室</a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://pic.3gbizhi.com/2021/1208/thumb_1680_0_20211208022357673.png)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">移动安全星球</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">主页</a><a class="site-page" href="/archives">归档</a><a class="site-page" href="/categories">分类</a><a class="site-page" href="/tags">标签</a><a class="site-page" href="/gallery">相册</a></span><span class="pull-right"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> 搜索</span></a></span></div><div id="post-info"><div id="post-title">如何在移动应用程序开发中正确使用加密技术</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2023-03-14</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E7%A7%BB%E5%8A%A8%E5%AE%89%E5%85%A8/">移动安全</a><span class="post-meta__separator">|</span><i class="fa fa-comment-o post-meta__icon" aria-hidden="true"></i><a href="/2023/03/14/%E5%A6%82%E4%BD%95%E5%9C%A8%E7%A7%BB%E5%8A%A8%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91%E4%B8%AD%E6%AD%A3%E7%A1%AE%E4%BD%BF%E7%94%A8%E5%8A%A0%E5%AF%86%E6%8A%80%E6%9C%AF/#disqus_thread"><span class="disqus-comment-count" data-disqus-identifier="2023/03/14/如何在移动应用程序开发中正确使用加密技术/"></span></a></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>首先我们来看看过去几年都发生了哪些因为加密技术使用不当或者未加密而导致的安全风险。</p>
<h3 id="KRACK攻击"><a href="#KRACK攻击" class="headerlink" title="KRACK攻击"></a>KRACK攻击</h3><p>时间：2017年10月</p>
<p>描述：KRACK攻击利用Wi-Fi加密标准WPA2的漏洞，允许攻击者窃取Wi-Fi网络中的敏感信息，如密码和其他私人数据。 </p>
<p>参考文章链接：<a target="_blank" rel="noopener" href="https://www.krackattacks.com/">https://www.krackattacks.com/</a></p>
<p>漏洞修复文章链接：<a target="_blank" rel="noopener" href="https://www.zdnet.com/article/krack-attack-patches-heres-where-the-bugs-are-lurking/">https://www.zdnet.com/article/krack-attack-patches-heres-where-the-bugs-are-lurking/</a></p>
<h3 id="WhatsApp远程执行代码漏洞"><a href="#WhatsApp远程执行代码漏洞" class="headerlink" title="WhatsApp远程执行代码漏洞"></a>WhatsApp远程执行代码漏洞</h3><p>时间：2019年5月 </p>
<p>描述：WhatsApp存在远程执行代码漏洞，攻击者可以通过向受害者发送一个特制的视频文件，来在其设备上执行任意代码。这个漏洞影响了大约1.5亿用户。 </p>
<p>参考文章链接：<a target="_blank" rel="noopener" href="https://thehackernews.com/2019/05/hacking-whatsapp-account.html">https://thehackernews.com/2019/05/hacking-whatsapp-account.html</a> </p>
<p>漏洞修复文章链接：<a target="_blank" rel="noopener" href="https://www.whatsapp.com/security/advisories/2019-07-15">https://www.whatsapp.com/security/advisories/2019-07-15</a></p>
<h3 id="Zoom加密漏洞"><a href="#Zoom加密漏洞" class="headerlink" title="Zoom加密漏洞"></a>Zoom加密漏洞</h3><p>时间：2020年4月 </p>
<p>描述：视频会议应用Zoom存在加密漏洞，攻击者可以轻松地窃取会议中的敏感信息。这个漏洞被广泛利用，引起了广泛的关注和担忧。 </p>
<p>参考文章链接：<a target="_blank" rel="noopener" href="https://thehackernews.com/2020/04/zoom-cybersecurity-hacking.html">https://thehackernews.com/2020/04/zoom-cybersecurity-hacking.html</a> </p>
<p>漏洞修复文章链接：<a target="_blank" rel="noopener" href="https://blog.zoom.us/wordpress/2020/04/09/zoom-rolling-out-security-enhancements-to-address-concerns/">https://blog.zoom.us/wordpress/2020/04/09/zoom-rolling-out-security-enhancements-to-address-concerns/</a></p>
<h3 id="COVID-19疫情相关的网络攻击"><a href="#COVID-19疫情相关的网络攻击" class="headerlink" title="COVID-19疫情相关的网络攻击"></a>COVID-19疫情相关的网络攻击</h3><p>时间：2020年 </p>
<p>描述：COVID-19疫情相关的网络攻击是一系列利用新冠病毒疫情来进行网络攻击的方法。这些攻击包括钓鱼邮件、恶意软件、虚假网站等，旨在窃取用户的个人信息、金融信息等。 </p>
<p>参考文章链接：<a target="_blank" rel="noopener" href="https://www.zdnet.com/article/coronavirus-themed-attacks-now-the-crowd-favorite-among-cybercriminals/">https://www.zdnet.com/article/coronavirus-themed-attacks-now-the-crowd-favorite-among-cybercriminals/</a> </p>
<h3 id="Freak漏洞"><a href="#Freak漏洞" class="headerlink" title="Freak漏洞"></a>Freak漏洞</h3><p>时间：2020年3月 </p>
<p>描述：Freak漏洞是一种利用加密算法中的漏洞来进行攻击的方法。该漏洞允许攻击者破解TLS/SSL连接中的加密，从而窃取传输的敏感信息。 </p>
<p>参考文章链接：<a target="_blank" rel="noopener" href="https://freakattack.com/">https://freakattack.com/</a> </p>
<p>漏洞修复文章链接：<a target="_blank" rel="noopener" href="https://www.us-cert.gov/ncas/alerts/TA15-086A">https://www.us-cert.gov/ncas/alerts/TA15-086A</a></p>
<p>那么我们如何在移动应用程序开发过程中正确使用加密技术呢？</p>
<h2 id="密码的作用"><a href="#密码的作用" class="headerlink" title="密码的作用"></a>密码的作用</h2><p>密码技术是保障网络与信息安全最有效、最可靠、最经济的手段，在信息安全方面发挥着重要作用，保证了信息的机密性、真实性、数据完整性和行为的不可否认性。</p>
<h3 id="保证信息的机密性"><a href="#保证信息的机密性" class="headerlink" title="保证信息的机密性"></a>保证信息的机密性</h3><p>信息的机密性是网络与信息安全的主要属性之一，是指确保信息不会泄露给未经授权的个人、计算机和其他实体的性质。</p>
<p>信息是网络空间中最有价值的资产信息，一旦泄露就可能会给国家、社会、行业、团体、个人带来巨大的危害和影响。</p>
<p>现实世界中，要保证信息的机密性，如将一份文件秘密保存或传递，一般可采用加装保护设施、增加警卫人员、藏匿或伪装等手段。而这些手段操作不便捷的同时，需要投入的人力物力大，人为风险因素多。</p>
<p>信息化时代，纸质文件、资料、书籍等信息被编码为计算机电子文件后，虽然大大提高了文件处理、传输和存储的能力，但为保证信息的机密性带来新的挑战。如电子文件被拷贝、截取和传播等诸多行为难以察觉。</p>
<p>密码学中的加密保护技术保证了信息的机密性。使用实现加密的计算机程序对电子文件加密生成形状乱码的密文，有了足够强大的加密算法防护，即使攻击者拦截到密文，也无法从密文中获取有用的信息。而拥有密钥的人则可以使用实现解密的计算机程序从乱码中恢复原始文件，获取正确信息。</p>
<p>信息安全中的访问控制技术采用口令技术防止非法用户进入某个应用系统的数据库，在一定程度上保证了信息的机密性。但这一技术仅相当于在数据库门口增加了“门卫”而数据本身仍然是明文状态，一旦攻击者绕过“门卫”或“门卫”失效，数据库毫无机密性可言。</p>
<h3 id="保证信息的真实性"><a href="#保证信息的真实性" class="headerlink" title="保证信息的真实性"></a>保证信息的真实性</h3><p>信息的真实性也是网络与信息安全的主要属性之一，是指保证信息来源可靠、没有被伪造和篡改的性质。</p>
<p>如何鉴别信息的合法性？如何确认真实的身份信息？这些都是网络与信息安全领域非常重要的任务。它们直接影响着社会秩序、生产生活秩序的各个方面。</p>
<p>现实生活中，可以通过相貌、声音、体态等体貌特征来确认人的身份，通过盖章、签字、手印等措施保证消息来源的可靠性。</p>
<p>信息化时代，在开放的网络环境下，身份信息和消息来源可以被伪造，电子信息和文件会被拷贝、截获和重用。</p>
<p>密码学中的安全认证技术解决了信息的真实性等问题。安全认证技术包括数字签名、消息认证码、身份认证协议等，基本思想是:合法用户拥有各自的“秘密信息”，可使用“秘密信息”处理公共信息并获得相应的“印章”用于证明公共信息的真实性。没有相应“秘密信息”的非法用户不能伪造“印章”。</p>
<p>其他可保证真实性的技术，如生物特征技术利用指纹、虹膜等进行身份认证，但它们如果不结合密码技术用于远程认证将非常不安全。</p>
<h3 id="保证数据的完整性"><a href="#保证数据的完整性" class="headerlink" title="保证数据的完整性"></a>保证数据的完整性</h3><p>数据完整性是网络与信息安全的又一个重要属性，表示数据是不是未经授权篡改或破坏的性质。</p>
<p>信息化时代带来了前所未有数据量、信息量、文件量等，各行各业都有大量公开传播和存储的数据，保证数据在传输、存储过程中不被篡改的任务艰巨，特别是在维护大量资料库、文件库时，更为艰巨。</p>
<p>现实生活中，可采用签名、盖章等手段保证数据完整性。</p>
<p>信息化时代，电子文档可采用水印技术，保护文件不被篡改，但电子文档完整性不易检测，被修改后很难发现。</p>
<p>对于大量的电子文件保护任务，哈希算法可以轻松实现数据完整性，通过称为摘要的数学过程，计算从文件中唯一的标识文件的特征信息。只要像这样的简短摘要附加到电子文件，就可以验证文件的完整性。要检查文件是否已被修改，只需使用哈希算法计算新摘要，将这个新的摘要与原来附带的摘要进行比对如果两个摘要一样，反之则证明已被修改。</p>
<h3 id="保证行为的不可否认性"><a href="#保证行为的不可否认性" class="headerlink" title="保证行为的不可否认性"></a>保证行为的不可否认性</h3><p>不可否认性同样是网络与信息安全的重要属性。</p>
<p>现实生活中发生的行为会留下证据或“集群”作为不可否认的证据。如在签署合同时，一方拒绝签署合同，那么他的签名就可以作为其拒绝行为不可否认性的证据。</p>
<p>信息化时代，如何防止已经在网络上验证的电子合同、电子报表等的不可否认是实现网络与信息安全的重要任务之一。</p>
<p>数字签名技术基于公钥的加密算法可以有效地解决行为的不可否认问题。一旦用户签署了数字签名就不能拒绝或拒绝他们。对解决网络上的纠纷、电子商务的纠纷等问题数字签名是必不可少的工具。虽然计算机、网络和信息系统的日志能在一定程度上证明用户的操作行为，但由于日志容易被伪造和篡改，因此无法保证行为的不可否认性。</p>
<h2 id="加密算法使用不当导致的安全风险"><a href="#加密算法使用不当导致的安全风险" class="headerlink" title="加密算法使用不当导致的安全风险"></a>加密算法使用不当导致的安全风险</h2><p>1、不安全的存储：移动客户端可能会将敏感数据（如密码和用户凭证）存储在明文或不安全的格式中，如明文文本文件或不加密的数据库中。</p>
<p>2、加密算法使用不当：加密算法的实现可能存在安全漏洞，如使用弱加密算法或未正确配置加密参数。此外，使用固定的密钥或硬编码密钥也可能导致安全漏洞。</p>
<p>3、未使用HTTPS：未使用HTTPS协议将移动应用程序与服务器之间的通信进行加密，可能会使敏感数据在传输过程中暴露给攻击者。</p>
<p>4、未正确验证证书：客户端应用程序可能会受到中间人攻击，这些攻击者可能会在通信链路上欺骗应用程序，以获取敏感数据。要解决此问题，应用程序需要正确验证服务器证书。</p>
<p>5、反向工程攻击：攻击者可能会对应用程序进行反向工程，以发现应用程序中存在的漏洞，并利用它们对应用程序进行攻击。</p>
<p>6、未更新的软件：移动客户端可能会运行过时的软件版本，这些版本可能包含已知的安全漏洞和弱点，攻击者可以利用这些漏洞进行攻击。</p>
<p>7、不安全的身份验证：使用不安全的身份验证方式，如明文传输密码或使用简单的身份验证方法（如基于cookie的身份验证），可能会导致攻击者轻松窃取用户凭证。</p>
<p>8、不良的代码实践：在代码实现过程中，可能存在逻辑错误和安全漏洞，例如缓冲区溢出、SQL注入、跨站脚本等。</p>
<p>9、未对用户数据进行合适的清除：应用程序可能会将敏感数据留存在本地设备上，例如用户凭证或私密聊天记录，这可能会导致安全隐患。</p>
<p>10、恶意软件攻击：恶意软件可能会通过植入移动应用程序中的恶意代码或通过攻击者拥有的恶意应用程序来攻击移动客户端，以获取敏感数据或控制设备。</p>
<h2 id="通信中安全性威胁"><a href="#通信中安全性威胁" class="headerlink" title="通信中安全性威胁"></a>通信中安全性威胁</h2><p>一般的，我们在网络中传输的数据，都可以认为是存在这潜在的风险的。用一句话来概括就是：“任何在网络中传输的明文数据都存在安全性威胁。”  </p>
<p><strong>下面就列举下我们通信中面临的四种威胁：</strong>  </p>
<p>- <strong>第一，中断</strong>。攻击者有意破坏和切断他人在网络上的通信，这是对可用性的攻击。<br>- <strong>第二，截获</strong>。属于被动攻击，攻击者从网络上窃听他人的通信内容，破坏信息的机密性。<br>- <strong>第三，篡改</strong>。攻击者故意篡改网络上传送的报文，这是对完整性的攻击。<br>- <strong>第四，伪造</strong>。攻击者伪造信息在网络传送，这是对真实性的攻击。  </p>
<p><img src="/2023/03/14/%E5%A6%82%E4%BD%95%E5%9C%A8%E7%A7%BB%E5%8A%A8%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91%E4%B8%AD%E6%AD%A3%E7%A1%AE%E4%BD%BF%E7%94%A8%E5%8A%A0%E5%AF%86%E6%8A%80%E6%9C%AF/1.png"></p>
<h2 id="密钥硬编码风险案例"><a href="#密钥硬编码风险案例" class="headerlink" title="密钥硬编码风险案例"></a>密钥硬编码风险案例</h2><h3 id="Android"><a href="#Android" class="headerlink" title="Android"></a>Android</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">encrypt</span><span class="params">(String data)</span>&#123;</span><br><span class="line">	<span class="keyword">try</span> &#123; </span><br><span class="line">		<span class="type">SecretKeySpec</span> <span class="variable">secretKeySpec</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SecretKeySpec</span>(<span class="string">&quot;49u5gh249gh24985ghf429gh4ch8f23f&quot;</span>.getBytes(),<span class="string">&quot;AES&quot;</span>); </span><br><span class="line">		<span class="type">Cipher</span> <span class="variable">instance</span> <span class="operator">=</span> Cipher.getInstance(<span class="string">&quot;AES&quot;</span>); </span><br><span class="line">		instance.init(<span class="number">1</span>, secretKeySpec); </span><br><span class="line">		<span class="keyword">return</span> Base64.encodeToString(instance.doFinal(data.getBytes())，<span class="number">0</span>); </span><br><span class="line">	<span class="keyword">catch</span>(Exception e)&#123; </span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br></pre></td></tr></table></figure>

<h3 id="iOS"><a href="#iOS" class="headerlink" title="iOS"></a>iOS</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"><span class="keyword">import</span> CommonCrypto</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">fileprivate</span> <span class="keyword">let</span> aesKey <span class="operator">=</span> <span class="string">&quot;gEKC8gte1FvR3oJV&quot;</span></span><br><span class="line"><span class="keyword">fileprivate</span> <span class="keyword">let</span> iv <span class="operator">=</span> <span class="string">&quot;MF00KFtxfibUyDWo&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Crypto</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">let</span> aesInstance <span class="operator">=</span> <span class="type">AESCrypto</span>(key: aesKey, iv: iv)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">init</span>()&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">func</span> <span class="title function_">encrypt</span>(<span class="keyword">_</span> <span class="params">string</span>: <span class="type">String</span>) -&gt; <span class="type">String</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> aesInstance.encrypt(string: string).base64EncodedString()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">func</span> <span class="title function_">decrypt</span>(<span class="keyword">_</span> <span class="params">data</span>: <span class="type">String</span>) -&gt; <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> aesInstance.decrypt(data: <span class="type">Data</span>(base64Encoded:data)<span class="operator">!</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fileprivate</span> <span class="keyword">class</span> <span class="title class_">AESCrypto</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">let</span> key: <span class="type">Data</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">let</span> iv: <span class="type">Data</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>(<span class="params">key</span>: <span class="params">String，iv</span>:<span class="type">String</span>)&#123;</span><br><span class="line">        <span class="keyword">guard</span> kevcount<span class="operator">=</span>kccKeySizeAEs128. <span class="keyword">let</span> kevData <span class="operator">=</span> kev.datalusina: .utf8) <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">preconditionFailure</span>(<span class="string">&quot;Error: Failed to set a key&quot;</span>)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">guard</span> iv.count <span class="operator">=</span> kcCBlockSizeAES128,<span class="keyword">let</span> ivData <span class="operator">=</span> iv.data(using: .utf8) <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">preconditionFailure</span>(<span class="string">&quot;Error: Failed to set an initial vector&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">                <span class="keyword">self</span>.key <span class="operator">=</span> kevData</span><br><span class="line">                <span class="keyword">self</span>.iv <span class="operator">=</span> ivData</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">func</span> <span class="title function_">encrypt</span>(<span class="params">string</span>: <span class="type">String</span>) -&gt; <span class="type">Data</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> status <span class="operator">=</span> cryptData.withUnsafeMutableBytes &#123; cryptBytes <span class="keyword">in</span></span><br><span class="line">            data.withUnsafeBytes &#123; dataBytes <span class="keyword">in</span></span><br><span class="line">                iv.withunsafeBytes &#123; ivBytes <span class="keyword">in</span></span><br><span class="line">                    key.withunsafeBytes &#123; keyBytes <span class="keyword">in</span></span><br><span class="line">                        <span class="type">CCCrypt</span>(option，<span class="type">CCAlgorithm</span>(kCCAlgorithmAES),options,keyBytes.baseAddress, keyLength, ivBytes.baseAddress</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="Android-SDK提供的加密相关API"><a href="#Android-SDK提供的加密相关API" class="headerlink" title="Android SDK提供的加密相关API"></a>Android SDK提供的加密相关API</h2><p>Android SDK使用的API和JAVA提供的基本相似，由以下部分组成：  </p>
<ul>
<li>Java Cryptography Architecture：JCA，java加密体系结构；</li>
<li>Java Cryptography Extension：JCE，Java加密扩展包)；</li>
<li>Java Secure Sockets Extension：JSSE，Java安全套接字扩展包；</li>
<li>Java Authentication and Authentication Service：JAAS，Java 鉴别与安全服务。    </li>
</ul>
<p>JCA提供基本的加密框架，如证书、数字签名、消息摘要和密钥对产生器，对应的Android API中的以下几个包：  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">java.security</span><br><span class="line">java.security.acl</span><br><span class="line">java.security.cert</span><br><span class="line">java.security.interfaces</span><br><span class="line">java.security.spec</span><br></pre></td></tr></table></figure>

<p>JCE扩展了JCA，提供了各种加密算法、摘要算法、密钥管理等功能，对应的Android API中的以下几个包：  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">javax.crypto</span><br><span class="line">javax.crypto.interfaces</span><br><span class="line">javax.crypto.spec</span><br></pre></td></tr></table></figure>

<p>JSSE提供了SSL（基于安全套接层）的加密功能，使用HTTPS加密传输使用，对应的Android API主要是java.net.ssl包中。  </p>
<p>JAAS 提供了在Java平台上进行用户身份鉴别的功能。对应的Android API主要在以下几个包：  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">javax.security.auth</span><br><span class="line">javax.security.auth.login</span><br><span class="line">javax.security.auth.callback</span><br><span class="line">javax.security.auth.x500</span><br></pre></td></tr></table></figure>

<p>它们其实只是一组接口，实际的算法是可由不同的Provider提供，Android API默认的Provider主要是是Bouncy Castle和OpenSSL。 此外Android API还提供了android.security和android.security.keystore（API 23新增）来管理keychain和keystore。</p>
<h2 id="常用算法之：Base64编码"><a href="#常用算法之：Base64编码" class="headerlink" title="常用算法之：Base64编码"></a>常用算法之：Base64编码</h2><p>Base64编码算法是一种用64个字符（ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/）来表示任意二进制数据的方法。在计算机网络发展的早期，由于“历史原因”，电子邮件不支持非ASCII码字符，如果要传送的电子邮件带有非ASCII码字符（诸如中文）或者图片，用户收到的电子邮件将会是一堆乱码，因此发明了Base64编码算法。至于为何会乱码？请大家自行Google。在加解密算法中，原始的数据和加密后的数据一般也是二进制数据，为了不传输出错，方便保存或者调试代码，一般需要对加密后的数据进行base64编码。  </p>
<p>Android提供了Base64编码的工具类android.util.Base64，可以直接使用，不用自己去实现base64编码的算法了。<strong>如：</strong>  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">byte</span>[] output = sha.digest();</span><br><span class="line"><span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> Base64.encodeToString(output, Base64.DEFAULT); </span><br></pre></td></tr></table></figure>

<h3 id="开发者建议"><a href="#开发者建议" class="headerlink" title="开发者建议"></a>开发者建议</h3><p>base64只是一种编码方式，并不是一种加密算法，不要使用base64来加密数据。  </p>
<h2 id="常用算法之：随机数生成器"><a href="#常用算法之：随机数生成器" class="headerlink" title="常用算法之：随机数生成器"></a>常用算法之：随机数生成器</h2><p>在Android加密算法中需要随机数时要使用SecureRandom来获取随机数。 <strong>如：</strong>  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">SecureRandom</span> <span class="variable">sr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SecureRandom</span>();</span><br><span class="line"><span class="type">byte</span>[] output = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">16</span>]; </span><br><span class="line">sr.nextBytes(output); </span><br></pre></td></tr></table></figure>
<p>注意不要给SecureRandom设置种子。调用seeded constructor或者setSeed(byte[])是不安全的。SecureRandom()默认使用的是dev/urandom作为种子产生器，这个种子是不可预测的。  </p>
<h3 id="开发者建议-1"><a href="#开发者建议-1" class="headerlink" title="开发者建议"></a>开发者建议</h3><ul>
<li>不要使用Random类来获取随机数。</li>
<li>在使用SecureRandom时候，不要设置种子。使用以下函数设置种子都是有风险的： </li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SecureRandom.SecureRandom(<span class="type">byte</span>[] seed) </span><br><span class="line">SecureRandom.setSeed(<span class="type">long</span> seed)</span><br><span class="line">SecureRandom.setSeed(<span class="type">byte</span>[] seed) </span><br></pre></td></tr></table></figure>
<h2 id="常用算法之：Hash算法"><a href="#常用算法之：Hash算法" class="headerlink" title="常用算法之：Hash算法"></a>常用算法之：Hash算法</h2><p>Hash算法是指任意长度的字符串输入，此算法能给出固定n比特的字符串输出，输出的字符串一般称为Hash值。  </p>
<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul>
<li>抗碰撞性：寻找两个不同输入得到相同的输出值在计算上是不可行的，需要大量的时间去寻找到具有相同输出的两个输入字符串。</li>
<li>不可逆：不可从结果推导出它的初始状态。  </li>
</ul>
<p>抗碰撞性使得Hash算法对原始输入的任意一点更改，都会导致产生不同的Hash值，因此Hash算法可以用来检验数据的完整性。我们经常见到在一些网站下载某个文件时，网站还提供了此文件的hash值，以供我们下载文件后检验文件是否被篡改。 不可逆的特性使Hash算法成为一种单向密码体制，只能加密不能解密，可以用来加密用户的登录密码等凭证。  </p>
<h3 id="开发者建议-2"><a href="#开发者建议-2" class="headerlink" title="开发者建议"></a>开发者建议</h3><p>1、建议使用SHA-256、SHA-3算法:<br>如使用SHA-256算法对message字符串做哈希：  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">byte</span>[] input = message.getBytes();</span><br><span class="line"><span class="type">MessageDigest</span> <span class="variable">sha</span> <span class="operator">=</span> MessageDigest.getInstance(<span class="string">&quot;SHA-256&quot;</span>);</span><br><span class="line">sha.update(input);</span><br><span class="line"><span class="type">byte</span>[] output = sha.digest();</span><br><span class="line"><span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> Base64.encodeToString(output, Base64.DEFFAULT); </span><br></pre></td></tr></table></figure>
<p>2、不建议使用MD2、MD4、MD5、SHA-1、RIPEMD算法来加密用户密码等敏感信息：<br>这一类算法已经有很多破解办法，例如md5算法，网上有很多查询的字典库，给出md5值，可以查到加密前的数据。  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">MessageDigest</span> <span class="variable">md</span> <span class="operator">=</span> MessageDigest.getInstance(<span class="string">&quot;MD5&quot;</span>);</span><br><span class="line"><span class="type">byte</span>[] md5Bytes = md.digest(str.getBytes()); </span><br><span class="line"><span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> Base64.encodeToString(md5Bytes，Base64.DEFAULT); </span><br></pre></td></tr></table></figure>
<p>3、不要使用哈希函数做为对称加密算法的签名。  </p>
<p>4、注意：当多个字符串串接后再做hash，要非常当心：<br>如：字符串S，字符串T，串接做hash，记为 H (S||T)。但是有可能发生以下情况。如“builtin||securely” 和 “built||insecurely”的hash值是完全一样的。 如何修改从而避免上述问题产生？ 改为H(length(S) || S || T)或者 H(H(S)||H(T))或者H(H(S)||T)。  </p>
<p>实际开发过程中经常会对url的各个参数，做词典排序，然后取参数名和值串接后加上某个SECRET字符串，计算出hash值，作为此URL的签名， 如foo=1, bar=2, baz=3 排序后为bar=2, baz=3, foo=1，做hash的字符串为：SECRETbar2baz3foo1，在参数和值之间没有分隔符，则”foo=bar”和”foob=ar”的hash值是一样的，”foo=bar&amp;fooble=baz”和”foo=barfooblebaz”一样，这样通过精心构造的恶意参数就有可能与正常参数的hash值一样，从而骗过服务器的签名校验。  </p>
<h2 id="消息认证算法"><a href="#消息认证算法" class="headerlink" title="消息认证算法"></a>消息认证算法</h2><p>要确保加密的消息不是别人伪造的，需要提供一个消息认证码（MAC，Message authentication code）。 消息认证码是带密钥的hash函数，基于密钥和hash函数。密钥双方事先约定，不能让第三方知道。  </p>
<p>消息发送者使用MAC算法计算出消息的MAC值，追加到消息后面一起发送给接收者。接收者收到消息后，用相同的MAC算法计算接收到消息MAC值，并与接收到的MAC值对比是否一样。  </p>
<h3 id="开发者建议-3"><a href="#开发者建议-3" class="headerlink" title="开发者建议"></a>开发者建议</h3><p>建议使用HMAC-SHA256算法，避免使用CBC-MAC。 <strong>HMAC-SHA256例子如下：</strong>  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化.KeyGenerator</span></span><br><span class="line"><span class="type">KeyGenerator</span> <span class="variable">keyGenerator</span> <span class="operator">=</span> KeyGenerator.getInstance(<span class="string">&quot;HmacSHA256&quot;</span>);</span><br><span class="line"><span class="comment">//产生密钥</span></span><br><span class="line"><span class="type">SecretKey</span> <span class="variable">secretKey</span> <span class="operator">=</span> keyGenerator.generateKey();</span><br><span class="line"><span class="comment">//获取密钥</span></span><br><span class="line"><span class="type">byte</span>[] key = secretKey.getEncoded();</span><br><span class="line">Log.d(Base64.encodeToString(key，Base64.DEFAULT));</span><br><span class="line"></span><br><span class="line"><span class="comment">//还原密钥</span></span><br><span class="line"><span class="type">SecretKey</span> <span class="variable">restoreSecretKey</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SecretKeySpec</span>(key，<span class="string">&quot;HmacSHA256&quot;</span>);</span><br><span class="line"><span class="comment">//实例化MAC</span></span><br><span class="line"><span class="type">Mac</span> <span class="variable">mac</span> <span class="operator">=</span> Mac.getInstance(restoreSecretKey.getAlgorithm());</span><br><span class="line"><span class="comment">//初始化MAC</span></span><br><span class="line">mac.init(restoreSecretKey);</span><br><span class="line"><span class="comment">//执行摘要</span></span><br><span class="line"><span class="type">byte</span>[] hmacSHA256Bytes = mac.doFinal(message.getBytes()); </span><br><span class="line">result = Base64.encodeToString(hmacSHA256Bytes，Base64.DEFAULT):</span><br></pre></td></tr></table></figure>

<h2 id="对称加密算法"><a href="#对称加密算法" class="headerlink" title="对称加密算法"></a>对称加密算法</h2><p>在对称加密算法中，数据发信方将明文（原始数据）和加密密钥一起经过特殊加密算法处理后，使其变成复杂的加密密文发送出去。收信方收到密文后，若想解读原文，则需要使用加密用过的密钥及相同算法的逆算法对密文进行解密，才能使其恢复成可读明文。在对称加密算法中，使用的密钥只有一个，发收信双方都使用这个密钥对数据进行加密和解密，这就要求解密方事先必须知道加密密钥。<br>该算法的缺点是，如果一旦密钥泄漏，那么加密的内容将都不可信了。  </p>
<h3 id="开发者建议-4"><a href="#开发者建议-4" class="headerlink" title="开发者建议"></a>开发者建议</h3><p>1、建议使用AES算法。<br>2、DES默认的是56位的加密密钥，已经不安全，不建议使用。<br>3、注意加密模式不要使用ECB模式。ECB模式不安全，说明问题的经典的三张图片，如下：<br><strong>明文是：</strong><br><img src="/2023/03/14/%E5%A6%82%E4%BD%95%E5%9C%A8%E7%A7%BB%E5%8A%A8%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91%E4%B8%AD%E6%AD%A3%E7%A1%AE%E4%BD%BF%E7%94%A8%E5%8A%A0%E5%AF%86%E6%8A%80%E6%9C%AF/2.png"></p>
<p><strong>用ECB加密模式后：</strong><br><img src="/2023/03/14/%E5%A6%82%E4%BD%95%E5%9C%A8%E7%A7%BB%E5%8A%A8%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91%E4%B8%AD%E6%AD%A3%E7%A1%AE%E4%BD%BF%E7%94%A8%E5%8A%A0%E5%AF%86%E6%8A%80%E6%9C%AF/3.png"></p>
<p><strong>用CBC加密模式后：</strong><br><img src="/2023/03/14/%E5%A6%82%E4%BD%95%E5%9C%A8%E7%A7%BB%E5%8A%A8%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91%E4%B8%AD%E6%AD%A3%E7%A1%AE%E4%BD%BF%E7%94%A8%E5%8A%A0%E5%AF%86%E6%8A%80%E6%9C%AF/4.png"> </p>
<p>4、Android 提供的AES加密算法API默认使用的是ECB模式，所以要显式指定加密算法为：CBC或CFB模式，可带上PKCS5Padding填充。AES密钥长度最少是128位，推荐使用256位。  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//生成KEY</span></span><br><span class="line"><span class="type">KeyGenerator</span> <span class="variable">keyGenerator</span> <span class="operator">=</span> KeyGenerator.getInstance(<span class="string">&quot;AES&quot;</span>); </span><br><span class="line">keyGenerator.init(<span class="number">256</span>);</span><br><span class="line"><span class="comment">//产生密钥</span></span><br><span class="line"><span class="type">SecretKey</span> <span class="variable">secretKey</span> <span class="operator">=</span> keyGenerator.generateKey();</span><br><span class="line"><span class="comment">//获取密钥</span></span><br><span class="line"><span class="type">byte</span>[] keyBytes = secretKey.getEncoded();</span><br><span class="line">Log.d(<span class="string">&quot;AES KEY&quot;</span>, Base64.encodeToString(keyBytes，<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//还原密钥</span></span><br><span class="line"><span class="type">SecretKey</span> <span class="variable">key</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SecretKeySpec</span>(keyBytes, <span class="string">&quot;AES&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//加密</span></span><br><span class="line"><span class="type">Cipher</span> <span class="variable">cipher</span> <span class="operator">=</span> Cipher.getInstance(<span class="string">&quot;AES/CBC/PKCS5Padding&quot;</span>); </span><br><span class="line">cipher.init(Cipher.ENCRYPT_MODE, key);</span><br><span class="line"><span class="type">byte</span>[] encodeResult = cipher.doFinal(plainText.getBytes());</span><br><span class="line">Log.d(<span class="string">&quot;AESencode&quot;</span>, Base64.encodeToString(encodeResult, Base64.DEFAULT));</span><br></pre></td></tr></table></figure>

<h2 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h2><p>非对称加密算法需要两个密钥：公开密钥（publickey）和私有密钥（privatekey）。公开密钥与私有密钥是一对，如果用公开密钥对数据进行加密，只有用对应的私有密钥才能解密；如果用私有密钥对数据进行加密，那么只有用对应的公开密钥才能解密（这个过程可以做数字签名）。<br>非对称加密主要使用的是RSA算法。  </p>
<h3 id="开发者建议-5"><a href="#开发者建议-5" class="headerlink" title="开发者建议"></a>开发者建议</h3><p>1、注意密钥长度不要低于512位，建议使用2048位的密钥长度。 使用RSA进行数字签名的算法，如：  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//生成密钥</span></span><br><span class="line"><span class="type">KeyPairGenerator</span> <span class="variable">keyPairGenerator</span> <span class="operator">=</span> KeyPairGenerator.getInstance(<span class="string">&quot;RSA&quot;</span>); </span><br><span class="line">keyPairGenerator.initialize(<span class="number">2048</span>);</span><br><span class="line"><span class="type">KeyPair</span> <span class="variable">keyPair</span> <span class="operator">=</span> keyPairGenerator.generateKeyPair();</span><br><span class="line">RSAPublicKeyrsaPublicKey=(RSAPublicKey)keyPair.getPublic();</span><br><span class="line">RSAPrivateKeyrsaPrivateKey =(RSAPrivateKey)keyPair.getPrivate()</span><br><span class="line"></span><br><span class="line"><span class="comment">//签名</span></span><br><span class="line"><span class="type">PKCS8EncodedKeySpec</span> <span class="variable">pkcs8EncodedKeySpec</span> <span class="operator">=</span> newPKCS8EncodedKeySpec(rsaPrivateKey.getEncoded()) </span><br><span class="line"><span class="type">KeyFactory</span> <span class="variable">keyFactory</span> <span class="operator">=</span> KeyFactory <span class="title function_">getInstance</span><span class="params">(<span class="string">&quot;RSA&quot;</span>)</span>;</span><br><span class="line"><span class="type">PrivateKey</span> <span class="variable">privateKey</span> <span class="operator">=</span> keyFactory.generatePrivate(pkcs8EncodedKeySpec); </span><br><span class="line"><span class="type">signature</span> <span class="variable">signature</span> <span class="operator">=</span> Signature.getInstance(<span class="string">&quot;SHA256withRSA&quot;</span>); </span><br><span class="line">signature.initSign(privateKey);</span><br><span class="line">signature.update(src.getBytes());</span><br><span class="line"><span class="type">byte</span>[] result = signature.sign();</span><br></pre></td></tr></table></figure>
<p>2、使用RSA算法做加密，RSA加密算法应使用Cipher.getInstance(RSA/ECB/OAEPWithSHA256AndMGF1Padding)，否则会存在重放攻击的风险。 如：  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">KeyPairGenerator</span> <span class="variable">keyPairGenerator</span> <span class="operator">=</span></span><br><span class="line">KeyPairGenerator.getInstance(<span class="string">&quot;RSA&quot;</span>);</span><br><span class="line">keyPairGenerator.initialize(<span class="number">2048</span>);</span><br><span class="line"><span class="type">KeyPair</span> <span class="variable">keyPair</span> <span class="operator">=</span> keyPairGenerator.generateKeyPair();</span><br><span class="line">RSAPublicKeyrsaPublicKey=(RSAPublicKey)keyPair.getPublic();</span><br><span class="line">RSAPrivateKey rsaPrivateKey=(RSAPrivateKey)keyPair.getPrivate();</span><br><span class="line"></span><br><span class="line"><span class="comment">//公钥加密</span></span><br><span class="line"><span class="type">X509EncodedKeySpec</span> <span class="variable">x509EncodedKeySpec</span> <span class="operator">=</span> newX509EncodedKeySpec(rsaPublicKey.getEncoded()): </span><br><span class="line"><span class="type">KeyFactory</span> <span class="variable">keyFactory</span> <span class="operator">=</span> KeyFactory.getInstance(<span class="string">&quot;RSA&quot;</span>);</span><br><span class="line"><span class="type">PublicKey</span> <span class="variable">publicKey</span> <span class="operator">=</span> keyFactory.generatePublic(x509EncodedKeySpec);</span><br><span class="line"><span class="type">Cipher</span> <span class="variable">cipher</span> <span class="operator">=</span> Cipher.getInstance(<span class="string">&quot;RSA/ECB/OAEPWithSHA256AndMGF1Padding&quot;</span>); </span><br><span class="line">cipher.init(Cipher.ENCRYPT_MODE，publicKey); </span><br><span class="line"><span class="type">byte</span>[] result =cipher.doFinal(src.getBytes());</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"><span class="comment">//私钥解密</span></span><br><span class="line"><span class="type">PKCS8EncodedKeySpec</span> <span class="variable">pkcs8EncodedKeySpec</span> <span class="operator">=</span> newPKCS8EncodedKeySpec(rsaPrivateKey.getEncoded());</span><br><span class="line"><span class="type">KeyFactory</span> <span class="variable">keyFactory2</span> <span class="operator">=</span> KeyFactory.getInstance(<span class="string">&quot;RSA&quot;</span>);</span><br><span class="line"><span class="type">PrivateKey</span> <span class="variable">privateKey</span> <span class="operator">=</span> keyFactory2.generatePrivate(pkcs8EncodedKeySpec); </span><br><span class="line"><span class="type">Cipher</span> <span class="variable">cipher</span> <span class="operator">=</span> Cipher.getInstance(<span class="string">&quot;RSA/ECB/OAEPWithSHA256AndMGF1Padding&quot;</span>); </span><br><span class="line">cipher.init(Cipher.DECRYPT_MODE，privateKey);</span><br><span class="line"><span class="type">byte</span>[] result2 = cipher.doFinal(result); </span><br></pre></td></tr></table></figure>

<h2 id="加密算法PBE"><a href="#加密算法PBE" class="headerlink" title="加密算法PBE"></a>加密算法PBE</h2><p>PBE是一种基于口令的加密算法，其特点是使用口令代替了密钥，而口令由用户自己掌管，采用随机数杂凑多重加密等方法保证数据的安全性。  </p>
<p><strong>开发者建议：</strong><br>使用基于口令的加密算法PBE时，生成密钥时要加盐，盐的取值最好来自SecureRandom，并指定迭代次数。 如：  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化盐</span></span><br><span class="line">mSalt = <span class="keyword">new</span> <span class="title class_">byte</span>[SALT_LENGTH_BYTES]; </span><br><span class="line"><span class="type">SecureRandom</span> <span class="variable">sr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SecureRandom</span>(); </span><br><span class="line">sr.nextBytes(mSalt);</span><br><span class="line"></span><br><span class="line"><span class="type">SecretKeyFactory</span> <span class="variable">secretKeyFactory</span> <span class="operator">=</span> SecretKeyFactory.getInstance(KEY_GENERATOR_MODE);</span><br><span class="line">keySpec = <span class="keyword">new</span> <span class="title class_">PBEKeySpec</span>(password, salt, KEY_GEN_ITERATION_COUNT, KEY_LENGTH_BITS); </span><br><span class="line">secretKey = secretKeyFactory.generateSecret(keySpec); </span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="几条原则"><a href="#几条原则" class="headerlink" title="几条原则"></a>几条原则</h3><p>1、不要自己设计加密算法和协议，使用业界标准的算法。<br>2、对称加密算法不要使用ECB模式，不建议使用DES算法。<br>3、要选择合适长度的密钥。<br>4、要确保随机数生成器的种子具有足够的信息熵。<br>5、不要使用没有消息认证的加密算法加密消息，无法防重放。<br>6、当多个字符串拼接后做hash，要非常当心。<br>7、当给算法加盐取值时不要太短，不要重复。<br>8、使用初始化向量时IV时，IV为常量的CBC，CFB，GCM等和ECB一样可以重放，即采用上一个消息的最后一块密文作为下一个消息的IV，是不安全的。<br>9、密钥应遵循的原则 ：  </p>
<ul>
<li>（1）密钥不能为常量，应随机，定期更换，如果加密数据时使用的密钥为常量，则相同明文加密会得到相同的密文，很难防止字典攻击。  </li>
<li>（2）开发同学要防范密钥硬编码的问题。  </li>
</ul>
<h3 id="密钥存储安全性从高到低"><a href="#密钥存储安全性从高到低" class="headerlink" title="密钥存储安全性从高到低"></a>密钥存储安全性从高到低</h3><ul>
<li>密钥存储在硬件支持的Android KeyStore中</li>
<li>所有密钥都存储在服务器上，并在强身份验证后可用</li>
<li>主密钥存储在服务器上，用于加密存储在Android SharedPreferences中的其他密钥</li>
<li>密钥存储在Android KeyStore的软件实现中</li>
<li>主密钥存储在Android密钥库的软件实现中，用于加密存储在SharedPreferences中的其他密钥</li>
<li>所有密钥都存储在SharedPreferences中（不建议）</li>
<li>在源代码中硬编码加密密钥（不建议）</li>
<li>基于稳定属性的可预测模糊函数或密钥生成函数（不建议）</li>
<li>将生成的密钥存储在外部存储（如/sdcard/）（不建议）</li>
</ul>
<p>参考文章：</p>
<p><a target="_blank" rel="noopener" href="https://blog.oversecured.com/Use-cryptography-in-mobile-apps-the-right-way/">https://blog.oversecured.com/Use-cryptography-in-mobile-apps-the-right-way/</a></p>
<p><a target="_blank" rel="noopener" href="http://www.52im.net/thread-216-1-1.html">http://www.52im.net/thread-216-1-1.html</a></p>
<p>推荐阅读：<br><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/AWHTLT1CBMAI5tdXYzDXIA">移动应用人脸识别风险与检测</a><br><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/RzdyDWRZ4un2_mC4Om8XZg">过某加固Frida检测</a><br><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/dV2JzXfgjDdCmWRmE0glDA">某涉黄APP产业链分析</a></p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Andy</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://andy0619.github.io/2023/03/14/如何在移动应用程序开发中正确使用加密技术/">https://andy0619.github.io/2023/03/14/如何在移动应用程序开发中正确使用加密技术/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://andy0619.github.io">移动安全星球</a>！</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%8A%A0%E8%A7%A3%E5%AF%86/">加解密</a><a class="post-meta__tags" href="/tags/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/">信息安全</a></div><div class="post-qr-code"><div class="post-qr-code-item"><img class="post-qr-code__img" src="https://i.postimg.cc/76V7jP2h/Wechat-IMG427.jpg"><div class="post-qr-code__desc">知识星球</div></div><div class="post-qr-code-item"><img class="post-qr-code__img" src="https://i.postimg.cc/QCd5DLQb/Wechat-IMG426.jpg"><div class="post-qr-code__desc">微信好友</div></div></div><nav id="pagination"><div class="next-post pull-right"><a href="/2023/03/09/%E6%8A%93%E5%8C%85%E9%82%A3%E4%BA%9B%E4%BA%8B/"><span>抓包那些事</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="disqus_thread"></div><script>var unused = null;
var disqus_config = function () {
  this.page.url = 'https://andy0619.github.io/2023/03/14/%E5%A6%82%E4%BD%95%E5%9C%A8%E7%A7%BB%E5%8A%A8%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91%E4%B8%AD%E6%AD%A3%E7%A1%AE%E4%BD%BF%E7%94%A8%E5%8A%A0%E5%AF%86%E6%8A%80%E6%9C%AF/';
  this.page.identifier = '2023/03/14/如何在移动应用程序开发中正确使用加密技术/';
  this.page.title = '如何在移动应用程序开发中正确使用加密技术';
}
var d = document, s = d.createElement('script');
s.src = "https://" + 'Andy0619' +".disqus.com/embed.js";
s.setAttribute('data-timestamp', '' + +new Date());
(d.head || d.body).appendChild(s);</script><script id="dsq-count-scr" src="https://Andy0619.disqus.com/count.js" async></script></div></div><footer class="footer-bg" style="background-image: url(https://pic.3gbizhi.com/2021/1208/thumb_1680_0_20211208022357673.png)"><div class="layout" id="footer"><div class="copyright">&copy;2013 - 2023 By Andy</div><div class="framework-info"><span>驱动 - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="footer_custom_text">盛年不重来，一日难再晨。及时宜自勉，岁月不待人。</div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.9.0"></script><script src="/js/fancybox.js?version=1.9.0"></script><script src="/js/sidebar.js?version=1.9.0"></script><script src="/js/copy.js?version=1.9.0"></script><script src="/js/fireworks.js?version=1.9.0"></script><script src="/js/transition.js?version=1.9.0"></script><script src="/js/scroll.js?version=1.9.0"></script><script src="/js/head.js?version=1.9.0"></script><script src="/js/search/local-search.js"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a target="_blank" rel="noopener" href="https://github.com/wzpan/hexo-generator-search" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>