<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>某病毒APP防护破解</title>
    <url>/2022/05/11/blog1/</url>
    <content><![CDATA[<p>今天星友求助一个类似杀猪盘的样本。该样本有以下几个点需要攻克：</p>
<p>1、AndroidManifest.xml经过处理：<br><img src="/2022/05/11/blog1/1.png"><br>2、整个样本的字符串全部经过加密，解密方法名经过强混淆：<br><img src="/2022/05/11/blog1/2.png"><br>3、资源文件也经过了混淆：<br><img src="/2022/05/11/blog1/3.png"><br>4、样本伪加密：<br><img src="/2022/05/11/blog1/4.png"><br>5、样本无法安装（签名问题）：<br><img src="/2022/05/11/blog1/5.png"></p>
<p>接下来我们来解决一下2、5两个问题。</p>
<h3 id="样本无法安装"><a href="#样本无法安装" class="headerlink" title="样本无法安装"></a>样本无法安装</h3><p>我们看样本安装报错，提示签名问题，我们直接上Xposed模块:<a href="https://github.com/Xposed-Modules-Repo/com.coderstory.toolkit">核心破解</a><br>核心破解的主要功能：<br>1、允许降级安装应用<br>2、允许安装签名错误的apk<br>3、允许在使用不同签名的情况下覆盖安装<br>缺点：<br>当前版本只支持安卓10-12<br><img src="/2022/05/11/blog1/6.png"></p>
<h3 id="强混淆方法hook、字符串解密"><a href="#强混淆方法hook、字符串解密" class="headerlink" title="强混淆方法hook、字符串解密"></a>强混淆方法hook、字符串解密</h3><p><img src="/2022/05/11/blog1/7.png"><br>接下来我们hook一下这个加密方法，简单的hook我们直接使用objection即可：</p>
<p>hook 监测该类，可以看到只有这一个方法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">objection -g com.<span class="property">biaoqyun</span>.<span class="property">tongchengaglao</span> explore</span><br><span class="line">android hooking watch <span class="keyword">class</span> <span class="title class_">b6p</span>.<span class="property">alur0e</span>.<span class="property">fmjoi</span></span><br></pre></td></tr></table></figure>
<p><img src="/2022/05/11/blog1/8.png"><br>我们直接复制，hook该方法，报错，找不到这个方法：<br><img src="/2022/05/11/blog1/9.png"><br>这样看直接hook这个方法显然是有问题，因为其中包含了各种字符，frida在解析这个方法时由于乱码的原因，无法正常解析道这个类，这样看来我们只能想其他办法了。</p>
<p>曲线救国，可以试试hook它的上层调用a.c，打印对应的参数和返回值来看，其中的参数即是解密后的字符串。  </p>
<p>得到结果如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">android hooking watch class_method com.<span class="property">g</span></span><br><span class="line">aoyuan.<span class="property">mianshu</span>.<span class="property">k</span>.<span class="property">c</span>.<span class="property">a</span> --dump-args --dump-<span class="keyword">return</span></span><br></pre></td></tr></table></figure>
<p><img src="/2022/05/11/blog1/10.png"><br>从上图我们可以看到有RSA密钥，以及返回的一些URL。</p>
<p>这样的缺点是只能知道这一块的字符串解密内容，其他的还是无法定位，这样看还是需要hook这个混淆的方法。</p>
<p>我们的大佬提供了解决方法，可以hook混淆方法，展示一下hook到的结果：<br><img src="/2022/05/11/blog1/11.png"><br>我们也可以根据打印出来的字符串在jadx中搜索对应的字符串然后继续分析代码</p>
<p>hook代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Java</span>.<span class="title function_">perform</span>(</span><br><span class="line">    <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">var</span> targetClass = <span class="string">&quot;b6p.alur0e.fmjoi&quot;</span>;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">var</span> hookCls = <span class="title class_">Java</span>.<span class="title function_">use</span>(targetClass);</span><br><span class="line">        <span class="keyword">var</span> methods = hookCls.<span class="property">class</span>.<span class="title function_">getDeclaredMethods</span>();</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> methodname = <span class="built_in">encodeURIComponent</span>(methods[<span class="number">0</span>].<span class="title function_">toString</span>().<span class="title function_">replace</span>(<span class="regexp">/^.*?\.([^\s\.\(\)]+)\(.*?$/</span>, <span class="string">&quot;$1&quot;</span>));<span class="comment">//对字符串进行js自己编码</span></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">        hookCls[<span class="built_in">decodeURIComponent</span>(methodname)]<span class="comment">//使用的时候再去解码</span></span><br><span class="line">            .<span class="property">implementation</span> = <span class="keyword">function</span> (<span class="params">x</span>) &#123;</span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;参数：&quot;</span>, x);</span><br><span class="line">                <span class="keyword">var</span> result = <span class="variable language_">this</span>[<span class="built_in">decodeURIComponent</span>(methodname)](x);</span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;返回值：&quot;</span>,result);</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>病毒分析</category>
      </categories>
      <tags>
        <tag>病毒</tag>
        <tag>防护</tag>
        <tag>加固</tag>
        <tag>混淆</tag>
      </tags>
  </entry>
  <entry>
    <title>小米手机—Redmi K20 Pro刷Magisk、Xposed等环境</title>
    <url>/2022/05/11/blog2/</url>
    <content><![CDATA[<h3 id="手机解锁BL"><a href="#手机解锁BL" class="headerlink" title="手机解锁BL"></a>手机解锁BL</h3><p>1、我们到指定网站<a href="http://www.miui.com/unlock/download.html">http://www.miui.com/unlock/download.html</a> 下载解锁工具，得到解锁工具包后解压双击运行miflash_unlock.exe，登录自己账号。<br><img src="/2022/05/11/blog2/1.png"></p>
<p>2、手机关机状态下长按手机的“音量减键+电源键”，进入手机FASTBOOT模式（有个兔子的界面就是），然后数据线插入手机和电脑连接，如下显示已连接手机后，我们点击解锁即可等待解锁。<br><img src="/2022/05/11/blog2/2.png"><br><img src="/2022/05/11/blog2/3.png"></p>
<h3 id="刷入Magisk"><a href="#刷入Magisk" class="headerlink" title="刷入Magisk"></a>刷入Magisk</h3><p>高版本的Magisk可以通过卡刷和直接安装，本次我们按照<a href="https://topjohnwu.github.io/Magisk/install.html#samsung-system-as-root">官网介绍</a>来安装</p>
<p>1、首先我们要下载对应的系统镜像，因为我们需要boot.img文件，小米手机可到<a href="https://xiaomirom.com/">下载 小米ROM</a>下载，找到自己机型对应的系统版本即可，要和手机系统版本号一致。下载后需要解压提取其中boot.img文件，将文件push到我们的手机（adb push）。<br><img src="/2022/05/11/blog2/4.png"></p>
<p>2、我们还需要去<a href="https://github.com/topjohnwu/Magisk">Magisk github</a>下载安装文件。<br><img src="/2022/05/11/blog2/5.png"></p>
<p>3、将我们下载的Magisk安装包安装后打开，下图是我们已经安装好的Magisk，我们点击安装——下一步——选择并修补一个文件——选择我们要push到手机的boot.img文件即可<br><img src="/2022/05/11/blog2/6.png" width="50%"></p>
<img src="/2022/05/11/blog2/7.png" width="50%">

<img src="/2022/05/11/blog2/8.png" width="50%">

<img src="/2022/05/11/blog2/9.png" width="50%">

<p>4、接着上步，会生成一个magisk_patched_random_strings.img文件，我们将该文件copy到自己电脑即可（adb pull）<br><img src="/2022/05/11/blog2/10.png" width="50%"></p>
<p>5、接下来我们将copy到电脑的magisk_patched_random_strings.img文件重新刷入手机即可（还是boot分区）,最后重启即可。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fastboot flash boot magisk_patched_random_strings.img</span><br><span class="line">fastboot reboot</span><br></pre></td></tr></table></figure>

<h3 id="其他工具环境"><a href="#其他工具环境" class="headerlink" title="其他工具环境"></a>其他工具环境</h3><h4 id="LSPosed和Root-hide"><a href="#LSPosed和Root-hide" class="headerlink" title="LSPosed和Root hide"></a>LSPosed和Root hide</h4><p>我安装的是最新版的Magisk（V24），废除了之前的Riru,采用Zygisk替代<br><img src="/2022/05/11/blog2/11.png" width="50%"><br>我们打开后就可以下载对应的模块达到对应的目的，这个版本模块无法在Magisk里面下载更新，只能自己下载zip包本地安装，主要有几个</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Zygisk-LSPosed——替代之前的LSPosed、riru-edxposed</span><br><span class="line">Shamiko（可以和frida共存）——替代之前的riru-momohide、hide</span><br></pre></td></tr></table></figure>
<img src="/2022/05/11/blog2/12.png" width="50%">

<h4 id="Momo"><a href="#Momo" class="headerlink" title="Momo"></a>Momo</h4><p>这个工具主要就是检测我们手机都有哪些风险环境<br><img src="/2022/05/11/blog2/13.png" width="50%"></p>
<h3 id="Frida"><a href="#Frida" class="headerlink" title="Frida"></a>Frida</h3><p>这个不用过多介绍，直接官网下载push到手机，提权即可使用，(当然Magisk里面也有对应的插件)如果被检测，可以试试<code>strong-frida</code>，这里就不过多介绍了。</p>
<h3 id="安装burp证书"><a href="#安装burp证书" class="headerlink" title="安装burp证书"></a>安装burp证书</h3><p><img src="/2022/05/11/blog2/14.png"><br><img src="/2022/05/11/blog2/15.png"><br>导出的.crt文件push到手机上<br>我们在小米手机设置也搜索证书，选择要安装的证书安装，这样安装后应该在用户凭据下，我们需要把它移到系统凭据下，这时候就需要借助<code>Magisk</code>的<code>Move_Certificates</code>模块<br><img src="/2022/05/11/blog2/16.png" width="50%"><br><img src="/2022/05/11/blog2/17.png" width="50%"><br>我们找到<a href="https://github.com/Magisk-Modules-Repo/movecert"><code>Move_Certificates</code></a>模块安装后重启手机即可<br>重启手机后我们在设置里面搜索信任的凭证，可以看到我们的证书已经在系统凭据下了。<br><img src="/2022/05/11/blog2/18.png" width="50%"></p>
<p>这样我们就可以正常抓包了，但是对于有证书校验的客户端，我们还是需要配合<code>JustMePlush</code>、<a href="https://github.com/Fuzion24/JustTrustMe"><code>JustTrustMe</code></a>、<a href="https://github.com/ac-pm/SSLUnpinning_Xposed"><code>SSLUnpinning</code></a>等hook工具</p>
]]></content>
      <categories>
        <category>刷机</category>
        <category>逆向环境</category>
      </categories>
      <tags>
        <tag>刷机</tag>
        <tag>小米</tag>
        <tag>Magisk</tag>
        <tag>Xposed</tag>
        <tag>burp证书</tag>
      </tags>
  </entry>
  <entry>
    <title>Android加固little总结</title>
    <url>/2022/05/12/blog3/</url>
    <content><![CDATA[<h1 id="Android软件加固"><a href="#Android软件加固" class="headerlink" title="Android软件加固"></a>Android软件加固</h1><h2 id="Android软件加固概述"><a href="#Android软件加固概述" class="headerlink" title="Android软件加固概述"></a>Android软件加固概述</h2><p>从2012年开始，移动互联网进入快速发展阶段，Android App开发热潮的兴起，也推动了Android平台软件保护技术的发展。</p>
<ul>
<li>  <strong>为何做加固</strong>   </li>
</ul>
<ol>
<li> 保护核心代码  </li>
<li> 防止营销作弊的手段   </li>
<li> 防止代码被篡改 …</li>
</ol>
<h2 id="加固代际"><a href="#加固代际" class="headerlink" title="加固代际"></a>加固代际</h2><p>根据不同的理解，现在加固代际基本上可以按照五代或者三代去区分。</p>
<h3 id="第一代：动态加载类"><a href="#第一代：动态加载类" class="headerlink" title="第一代：动态加载类"></a>第一代：动态加载类</h3><p>Apk中没有完整原始的Dex，需要运行时动态的加载到内存中</p>
<h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><ul>
<li><p>  落地加载<br>我们拿到需要加密的Apk和自己的壳程序Apk，然后用加密算法对源Apk进行加密再将壳Apk进行合并得到新的Dex文件，最后替换壳程序中的dex文件即可，得到新的Apk,那么这个新的Apk我们也叫作脱壳程序Apk.他已经不是一个完整意义上的Apk程序了，他的主要工作是：负责解密源Apk.然后加载Apk,让其正常运行起来。运行时首先将我们的Dex文件或者Apk文件解密，然后利用DexClassLoader加载器将其加载进内存中，然后利用反射加载待加固的Apk的Appkication，然后运行待加固程序即可。<br><img src="/2022/05/12/blog3/1.png"><br><img src="/2022/05/12/blog3/2.png"></p>
</li>
<li><p>  不落地加载<br>落地加载将Dex文件解密出来会保存到文件中，再通过DexClassLoader加载进内存中，而不落地加载直接重写DexClassLoader使其可以直接加载字节数组，避免写入文件中。我们要做的是重写DexClassLoader，而这涉及到三个函数defineClass、findClass、loadClass，在一个类被加载的时候，会先后调用这三个函数加载一个类，所以我们需要重写这三个函数。系统的DexClassLoader加载Dex进入内存的也必然是通过字节加载的，而在系统so中的libdvm.so中的openDexFile可以直接加载Dex文件，那么现在清楚了，我们可以通过编写so文件调用openDexFile函数加载Dex字节数组，值得注意的是，openDexFile函数返回值为一个int类型的cookie，可以简单理解成一个dex文件的’身份码’，通过该’身份码’即可操控这个dex文件,至于怎么调用该函数，可以通过dlopen和dlsym函数调用。</p>
</li>
</ul>
<p><img src="/2022/05/12/blog3/3.png"></p>
<h4 id="优劣"><a href="#优劣" class="headerlink" title="优劣"></a>优劣</h4><ul>
<li><p>  优点<br>比较容易实现，无明显的兼容性问题 能有效对抗静态分析和二次打包</p>
</li>
<li><p>  缺点<br>启动时需要进行大量的解密运算，容易造成卡死的情况 在内存中的数据为完整的Dex，通过动态调试Dump内存即可获取完整的Dex</p>
</li>
</ul>
<h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><p><img src="/2022/05/12/blog3/4.png"><br>Dex字符串加密 资源加密 对抗反编译 对抗调试 Dex动态加载 so加密</p>
<h3 id="第二代：函数抽取类"><a href="#第二代：函数抽取类" class="headerlink" title="第二代：函数抽取类"></a>第二代：函数抽取类</h3><h4 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h4><p>主要分为两个步骤指令抽取和指令还原</p>
<ul>
<li>  指令抽取<br>解析原始Dex文件格式，保存所有方法的代码结构体信息，通过传入需要置空指令的方法和类名，检索到其代码结构体信息。通过方法的代码结构体信息获取指令个数和偏移地址，构造空指令集，然后覆盖原始指令，重新计算dex文件的checksum和signature信息，回写到头部信息中。</li>
</ul>
<p><img src="/2022/05/12/blog3/5.png"></p>
<p><img src="/2022/05/12/blog3/6.png"></p>
<ul>
<li>  指令还原<br>native层hook系统函数dexFindClass，获取类结构体信息（dexFindClass函数用于查找类的DexClassDef结构），获取类中所有的方法信息，通过指定方法名进行过滤，获取该方法的代码结构体信息，获取该方法被抽取的指令集，修改方法对应的内存地址为可读属性，直接进行指令还原。</li>
</ul>
<h4 id="优劣-1"><a href="#优劣-1" class="headerlink" title="优劣"></a>优劣</h4><ul>
<li><p>  优点<br>加密粒度变小，加密技术从Dex文件级变为方法级 按需解密，解密操作延迟到某类方法被执行前，如果方法不被执行，则不被解密 解密后的代码在内存不连续，克服了内存被Dump的缺点，有效保护了移动客户端的Java代码</p>
</li>
<li><p>  缺点<br>使用大量的虚拟机内部结构，会出现兼容性问题，无法保护所有方法 无法对抗自定义虚拟机 它跟虚拟机的JIT优化出现冲突，达不到最佳的性能表现</p>
</li>
</ul>
<h4 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h4><p><img src="/2022/05/12/blog3/7.png"></p>
<p>除一代有的特点外 内存中无完整、连续的Dex so代码混淆、膨胀</p>
<h3 id="第三代：VMP、Dex2C类"><a href="#第三代：VMP、Dex2C类" class="headerlink" title="第三代：VMP、Dex2C类"></a>第三代：VMP、Dex2C类</h3><h4 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h4><ul>
<li>  VMP<br>执行到关键代码时进入壳so执行，关于这一点，不同的厂商有着不同的做法，比如把关键函数变成native函数，在壳so中动态或者静态注册</li>
</ul>
<p><img src="/2022/05/12/blog3/8.png"></p>
<p>再比如更改关键方法的方法体</p>
<p><img src="/2022/05/12/blog3/9.png"></p>
<p>无论哪种方法其实都是为了能让壳函数代替原函数去执行 当执行该函数的指令时，解析出指令的OpCode,通过一个巨大的switch case找到处理对应OpCode的函数，然后执行</p>
<p><img src="/2022/05/12/blog3/10.png"></p>
<p>简单讲就是壳将原本的指令进行一次封装，将原本的指令转换为另一种表现形式</p>
<ul>
<li>  Dex2C<br>首先也是将关键代码注册为native函数，主要借助于JNI反射技术，将Java层的方法全部反射为native层，增大分析难度。之后再通过混淆、字符串加密等操作生成so，最后将so进行加固保护。</li>
</ul>
<h4 id="优劣-2"><a href="#优劣-2" class="headerlink" title="优劣"></a>优劣</h4><ul>
<li><p>  优点<br>加固强度高，目前没有公开的脱壳工具 经过混淆加密后很难还原原函数</p>
</li>
<li><p>  缺点<br>效率较低，启动、运行时都比较耗时稳定性、可控性差，容易产生崩溃</p>
</li>
</ul>
<h4 id="特点-2"><a href="#特点-2" class="headerlink" title="特点"></a>特点</h4><p><img src="/2022/05/12/blog3/11.png"></p>
<p>除一、二代全部特点外 so代码虚拟化 对抗之前所有的脱壳方法</p>
<h3 id="so加密"><a href="#so加密" class="headerlink" title="so加密"></a>so加密</h3><h4 id="section加密"><a href="#section加密" class="headerlink" title="section加密"></a>section加密</h4><ul>
<li>  原理<br>将关键方法，存放在自定义的section中，通过解析每个section，将我们自定义的section进行加密。因为so在加载时会优先加载.init_array，所以将解密方法放在.init_array中，获取内存中各个section的起始地址和大小，将需要解密的section还原。</li>
</ul>
<h4 id="函数加密"><a href="#函数加密" class="headerlink" title="函数加密"></a>函数加密</h4><ul>
<li>  原理<br>解析so，根据方法名找到指定的方法，将方法进行加密。加载so时，获取指定方法的地址，通过解密方法将指定方法解密。</li>
</ul>
<h4 id="特点-3"><a href="#特点-3" class="headerlink" title="特点"></a>特点</h4><p><img src="/2022/05/12/blog3/12.png"></p>
<p><img src="/2022/05/12/blog3/13.png"></p>
<p>由于原本的指令已经被加密成其他的字节，IDA等静态分析工具中会出现大段无法识别的代码</p>
<h2 id="各厂商特征"><a href="#各厂商特征" class="headerlink" title="各厂商特征"></a>各厂商特征</h2><p>除此外还有很多大佬们可以自行总结</p>
<h3 id="某梆"><a href="#某梆" class="headerlink" title="某梆"></a>某梆</h3><p>lib/libDexHelper.so、lib/libDexHelper-x86.so、</p>
<h3 id="某加密"><a href="#某加密" class="headerlink" title="某加密"></a>某加密</h3><p>assets/ijiami.ajm、assets/ijiami.dat、assets/ijm_lib/libexec.so、assets/ijm_lib/libexecmain.so</p>
<h3 id="某企鹅"><a href="#某企鹅" class="headerlink" title="某企鹅"></a>某企鹅</h3><p>lib/libshell-super.2019.so、lib/libshella-4.1.0.29.so</p>
<h3 id="某数字"><a href="#某数字" class="headerlink" title="某数字"></a>某数字</h3><p>assets/libjiagu.so、assets/libjiagu_x86.so</p>
<h3 id="某迦"><a href="#某迦" class="headerlink" title="某迦"></a>某迦</h3><p>lib/libxloader.so</p>
<p>assets/libvdog、assets/libvdog64、assets/libvdog-x86</p>
<h3 id="某付盾"><a href="#某付盾" class="headerlink" title="某付盾"></a>某付盾</h3><p>lib/libegis.so、lib/libegis-x86.so</p>
<h2 id="脱壳工具"><a href="#脱壳工具" class="headerlink" title="脱壳工具"></a>脱壳工具</h2><h3 id="FRIDA-DEXDump"><a href="#FRIDA-DEXDump" class="headerlink" title="FRIDA-DEXDump"></a>FRIDA-DEXDump</h3><h4 id="原理-3"><a href="#原理-3" class="headerlink" title="原理"></a>原理</h4><p>通过Frida在内存中搜索dex\n035，因为Dex的头部都会存在一个dex\n035的模数，所以通过在内存中搜索dex\n035可以搜索到Dex文件。对于一些Dex它们被抹去了头部信息，对于这样的情况，FRIDA-DEXDump也提供了对应的方法，通过遍历当前进程中所有可以读的内存段，通过判断这个段的大小和Dex文件中一些关键区域的关系可以判断是否为一个Dex。</p>
<h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p>在FRIDA-DEXDumpGitHub中下载代码到本地或者通过<code>pip3 install frida-dexdump</code> 安装</p>
<p><img src="/2022/05/12/blog3/14.png"></p>
<p>用法就是首先打开，我们需要脱壳的软件，然后执行<code>python main.py -d</code>程序执行开始检索内存中的Dex</p>
<p><img src="/2022/05/12/blog3/15.png"></p>
<p>检索到后会保存在SavePath对应的目录下</p>
<p>也可以通过<code>python main.py -h</code>查看它的其他使用方法</p>
<p><img src="/2022/05/12/blog3/16.png"></p>
<p>最终得到它脱出来的Dex，可以看下它脱壳效果</p>
<p><img src="/2022/05/12/blog3/17.png"></p>
<h3 id="Youpk"><a href="#Youpk" class="headerlink" title="Youpk"></a>Youpk</h3><h4 id="原理-4"><a href="#原理-4" class="headerlink" title="原理"></a>原理</h4><p>从ClassLinker中遍历所有DexFile对象，在虚拟机中Dex文件都用DexFile对象来表示，并Dump出所有Dex文件。此时只是整体Dump，Dex中的方法还未还原。遍历DexFile中的ClassDef结构，获取到所有Class，主动调用Class中的所有的方法，让程序强制走switch解释器执行，在解释器中添加Hook代码，当方法执行时自动保存CodeItem。根据保存的CodeItem和Dump下来的Dex进行合并，还原Dex中被抽取的指令。</p>
<h4 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h4><p>首先下载刷机包和还原工具，目前仅支持刷pixel 1手机</p>
<p><img src="/2022/05/12/blog3/18.png"></p>
<p>解压相关的镜像，<code>fastboot flash xxx /Download/xxx.img</code>依次刷入</p>
<p><img src="/2022/05/12/blog3/19.png"></p>
<p>配置待脱壳的App包名<code>adb shell &quot;echo com.xxx &gt;&gt; /data/local/tmp/unpacker.config&quot;</code></p>
<p>启动Apk等待脱壳，每隔10秒将自动重新脱壳(已完全dump的dex将被忽略), 当日志打印unpack end时脱壳完成</p>
<p>dump文件路径为/data/data/包名/unpacker，使用adb命令将文件pull出</p>
<p><img src="/2022/05/12/blog3/20.png"></p>
<p>使用dexfixer.jar修复Dex，<code>java -jar dexfixer.jar /path/unpacker /path/output</code></p>
<p>最后我们对比一下还原前后的代码</p>
<p>还原前</p>
<p><img src="/2022/05/12/blog3/21.png"></p>
<p>还原后</p>
<p><img src="/2022/05/12/blog3/22.png"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文简单地总结了一下Android加固的背景和发展历史，也介绍了一些目前常见的脱壳工具。对于so加密的情况，目前也有许多方法应对，比如ida动态调试dump内存中的so，GG模拟器dump内存，frida dump so，unidbg等等。对于混淆的so，也有jnitrace，unidbg，还有hluwa大佬的大作obpo等工具辅助我们分析。除此以外还有还有一些优秀的脱壳工具如Fart等，我也没有再做介绍了。总之感谢这些大佬们的努力和开源，没有你们就没有白嫖的我们，哈哈…</p>
]]></content>
      <categories>
        <category>Android防护手段</category>
      </categories>
      <tags>
        <tag>防护</tag>
        <tag>加固</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo&amp;github 搭建属于自己的博客</title>
    <url>/2022/05/12/blog4/</url>
    <content><![CDATA[<h2 id="安装-Hexo"><a href="#安装-Hexo" class="headerlink" title="安装 Hexo"></a>安装 Hexo</h2><ol>
<li><p>安装 Hexo 相当简单，只需要先安装下列应用程序即可：</p>
<ul>
<li>  <a href="http://nodejs.org/">Node.js</a> (Node.js 版本需不低于 10.13，建议使用 Node.js 12.0 及以上版本)</li>
<li>  <a href="http://git-scm.com/">Git</a></li>
</ul>
</li>
<li><p>具备以上环境后我们安装hexo</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install hexo</span><br><span class="line">npm install hexo-cli g  #推荐</span><br></pre></td></tr></table></figure></li>
<li><p>配置系统环境变量</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">echo &#x27;PATH=&quot;$PATH:./node_modules/.bin&quot;&#x27; &gt;&gt; ~/.zshrc</span><br></pre></td></tr></table></figure></li>
<li><p>在选好的目录下运行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo init [文件夹名称]   <span class="comment">#新建一个网站 hexo init blog</span></span><br><span class="line"><span class="built_in">cd</span> [文件夹名称]			<span class="comment">#进入网站目录</span></span><br><span class="line">hexo s				   <span class="comment">#启动服务器</span></span><br></pre></td></tr></table></figure></li>
<li><p>通过以上步骤，最简单的hexo网站就好了，可以直接访问<a href="http://localhost:4000/%EF%BC%8C%E6%9D%A5%E7%9C%8Bhexo%E8%87%AA%E5%B8%A6%E7%9A%84%E4%B8%BB%E9%A2%98,%E6%8E%A5%E4%B8%8B%E6%9D%A5%E6%88%91%E4%BB%AC%E9%9C%80%E8%A6%81%E6%9B%B4%E6%8D%A2%E8%87%AA%E5%B7%B1%E5%96%9C%E6%AC%A2%E7%9A%84%E4%B8%BB%E9%A2%98%E3%80%82">http://localhost:4000/，来看hexo自带的主题,接下来我们需要更换自己喜欢的主题。</a></p>
</li>
</ol>
<h2 id="下载喜欢的主题"><a href="#下载喜欢的主题" class="headerlink" title="下载喜欢的主题"></a>下载喜欢的主题</h2><ol>
<li>在我们的网站目录下载安装对应主题即可：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-theme-melody</span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li>因为我们hexo版本大于5.0，所以我们要做如下配置，创建一个属于melody主题的配置文件：</li>
<li>在网站目录下创建一个 <code>_config.melody.yml</code></li>
<li>将 <code>./node_modules/hexo-theme-melody/_config.yml</code>里面的内容拷贝到<code>_config.melody.yml</code></li>
<li>然后在网站目录下的<code>_config.yml</code>配置文件中的theme进行配置<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">theme: melody <span class="comment"># 将主题设置成melody</span></span><br></pre></td></tr></table></figure></li>
</ul>
<ol start="2">
<li>后续melody主题更新了，我们进行如下操作即可：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm update hexo-theme-melody   <span class="comment">#平滑升级主题</span></span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li>推荐其他主题：<code>git clone https://github.com/blinkfox/hexo-theme-matery.git</code></li>
</ul>
<h2 id="部署我们的项目到github"><a href="#部署我们的项目到github" class="headerlink" title="部署我们的项目到github"></a>部署我们的项目到github</h2><h3 id="在自己的github上创建仓库"><a href="#在自己的github上创建仓库" class="headerlink" title="在自己的github上创建仓库"></a>在自己的github上创建仓库</h3><ol>
<li>注册github账户并登录，点击新建仓库</li>
<li>命名为xxx.github.io（xxx为自己GitHub的账户名），点击创建</li>
</ol>
<h3 id="在本地生成SSH公钥并绑定到github"><a href="#在本地生成SSH公钥并绑定到github" class="headerlink" title="在本地生成SSH公钥并绑定到github"></a>在本地生成SSH公钥并绑定到github</h3><ol>
<li><p>设置git的用户名和邮箱</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global user.name <span class="string">&quot;yourname&quot;</span> </span><br><span class="line">git config --global user.email <span class="string">&quot;youremail&quot;</span></span><br><span class="line">ssh-keygen -t rsa -C <span class="string">&quot;youremail&quot;</span>  <span class="comment">#关键命令</span></span><br></pre></td></tr></table></figure>
<p><img src="/2022/05/12/blog4/1.png"></p>
</li>
<li><p>生成之后我们可以运行以下命令测试是否绑定成功：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure></li>
<li><p>找到生成Key值的目录,前往.ssh目录、查看对应的公钥</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> ~/.ssh/id_rsa.pub</span><br></pre></td></tr></table></figure>
<p><img src="/2022/05/12/blog4/2.png"></p>
</li>
<li><p>登录对应的git服务器、将公钥（id_rsa.pub中的内容）添加上去<br><img src="/2022/05/12/blog4/3.png"><br><img src="/2022/05/12/blog4/4.png"></p>
</li>
</ol>
<h3 id="将hexo部署到GitHub"><a href="#将hexo部署到GitHub" class="headerlink" title="将hexo部署到GitHub"></a>将hexo部署到GitHub</h3><ol>
<li>在我们的配置文件<code>_config.yml</code>中做以下配置：<br><img src="/2022/05/12/blog4/5.png"></li>
<li>接下来我们运行以下命令部署我们的博客到github上：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo clean  <span class="comment">#删除生成的文件和缓存</span></span><br><span class="line">hexo g      <span class="comment">#生成静态文件，也就是public文件夹</span></span><br><span class="line">hexo d      <span class="comment">#部署网站</span></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">第一次hexo d命令需要输入用户名和密码，这里密码需要到github设置里面生成token，而不能用登录密码，具体生成方法参考下面内容。</span><br></pre></td></tr></table></figure></li>
<li>最后我们直接访问我们的博客即可 <code>http://(github用户名).github.io</code></li>
</ol>
<h3 id="hexo-d-命令报错"><a href="#hexo-d-命令报错" class="headerlink" title="hexo d 命令报错"></a>hexo d 命令报错</h3><ol>
<li>“# ERROR Deployer not found: git”<br>原因：这是因为没安装<code>hexo-deployer-git</code>插件，在项目目录下运行以下命令安装即可：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure></li>
<li>“Support for password authentication was removed on August 13, 2021”<br>原因：2021年8月31日开始就不能使用密码凭证，必须使用个人访问令牌（personal access token），就是把你的密码替换成token！</li>
</ol>
<h4 id="为什么要把密码换成token"><a href="#为什么要把密码换成token" class="headerlink" title="为什么要把密码换成token"></a>为什么要把密码换成token</h4><p><strong>下面是Github官方的解释：</strong> 近年来，GitHub 客户受益于 <a href="https://link.zhihu.com/?target=http://GitHub.com" title="http://GitHub.com">http://GitHub.com</a> 的许多安全增强功能，例如双因素身份验证、登录警报、经过验证的设备、防止使用泄露密码和 WebAuthn 支持。 这些功能使攻击者更难获取在多个网站上重复使用的密码并使用它来尝试访问您的 GitHub 帐户。 尽管有这些改进，但由于历史原因，未启用双因素身份验证的客户仍能够仅使用其GitHub 用户名和密码继续对 Git 和 API 操作进行身份验证。</p>
<p>从 2021 年 8 月 13 日开始，我们将在对 Git 操作进行身份验证时不再接受帐户密码，并将要求使用基于令牌（token）的身份验证，例如个人访问令牌（针对开发人员）或 OAuth 或 GitHub 应用程序安装令牌（针对集成商） <a href="https://link.zhihu.com/?target=http://GitHub.com" title="http://GitHub.com">http://GitHub.com</a> 上所有经过身份验证的 Git 操作。 您也可以继续在您喜欢的地方使用 SSH 密钥（<a href="https://link.zhihu.com/?target=https://cloud.tencent.com/developer/article/1861466" title="如果你要使用ssh密钥可以参考">如果你要使用ssh密钥可以参考</a>）。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">**修改为token的好处：**</span><br><span class="line">令牌（token）与基于密码的身份验证相比，令牌提供了许多安全优势： - 唯一： 令牌特定于 GitHub，可以按使用或按设备生成 - 可撤销：可以随时单独撤销令牌，而无需更新未受影响的凭据 - 有限 ： 令牌可以缩小范围以仅允许用例所需的访问 - 随机：令牌不需要记住或定期输入的更简单密码可能会受到的字典类型或蛮力尝试的影响。</span><br></pre></td></tr></table></figure>

<h4 id="如何生成token"><a href="#如何生成token" class="headerlink" title="如何生成token"></a>如何生成token</h4><p>打开Github，在个人设置页面，找到【Setting】，然后打开找到【Devloper Settting】，如下图。<br><img src="/2022/05/12/blog4/6.png"><br>然后，选择个人访问令牌【Personal access tokens】，然后选中生成令牌【Generate new token】。<br><img src="/2022/05/12/blog4/7.png"><br><img src="/2022/05/12/blog4/8.png"><br>选择要授予此令牌token的范围或权限。</p>
<ul>
<li>  要使用token从命令行访问仓库，请选择repo</li>
<li>  要使用token从命令行删除仓库，请选择delete_repo</li>
<li>  其他根据需要进行勾选</li>
</ul>
<p>然后，点击【Generate token】生成令牌。</p>
<p>我们在hexo d的时候输入生成的token即可<br><img src="/2022/05/12/blog4/9.png"></p>
<h3 id="hexo-d后没有报错，但是网站访问报错"><a href="#hexo-d后没有报错，但是网站访问报错" class="headerlink" title="hexo d后没有报错，但是网站访问报错"></a>hexo d后没有报错，但是网站访问报错</h3><p>报错内容如下图：<br><img src="/2022/05/12/blog4/18.png"><br>处理方式：在博客目录下打开<code>git bash here</code>（mac不需要，直接在博客目录下输入后面命令即可），输入命令：<code>npm install --save hexo-renderer-jade hexo-generator-feed hexo-generator-sitemap hexo-browsersync hexo-generator-archive</code></p>
<h2 id="写博客"><a href="#写博客" class="headerlink" title="写博客"></a>写博客</h2><h3 id="博文中图片的处理"><a href="#博文中图片的处理" class="headerlink" title="博文中图片的处理"></a>博文中图片的处理</h3><ol>
<li>我们直接使用本地图片，按照Markdown格式写，然后一起部署到github上即可</li>
<li>我们需要在配置文件中做如下配置：把<code>_config.yml</code>中的<code>post_asset_folder</code>设为<code>true</code><br><img src="/2022/05/12/blog4/10.png"><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">以上配置的意思就是我们每次hexo new 博客时，就会在同目录下生成一个和博客名一样的文件夹，这个文件夹就可以放我们的图片，如下图：</span><br></pre></td></tr></table></figure>
<img src="/2022/05/12/blog4/11.png"></li>
<li>要添加图片，先npm install 一个hexo-asset-image的依赖</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-asset-image --save</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>之后我们就可以在我们的md文件中正常引用了,<strong>不需要加任何前缀</strong>，只需要把我们图片的名字copy到括号中就行，网上很多都是要加文件夹名称，实践的结果是不行，啥都不加最好使。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">![](001.jpg)</span><br></pre></td></tr></table></figure>
这里如果我们的图片分辨率较大，需要按照html格式写，按照自己喜好设置图片显示的大小<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;001.png&quot;</span> <span class="attr">width</span> = <span class="string">50%</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="配置顶部背景图、头像、文章底部二维码"><a href="#配置顶部背景图、头像、文章底部二维码" class="headerlink" title="配置顶部背景图、头像、文章底部二维码"></a>配置顶部背景图、头像、文章底部二维码</h3><ol>
<li><p>这些图片都是在配置文件中配置的，只能使用图片的Url，如果是本地应用，可能导致无法显示，或者有些页面显示有些页面不显示。</p>
</li>
<li><p>我背景图、头像都是找的网图，直接复制网图链接就可以</p>
</li>
<li><p>在我们的配置文件<code>_config.melody.yml</code>中设置对应的标签即可：<br><img src="/2022/05/12/blog4/12.png"></p>
</li>
<li><p>如果是文章底部推广二维码，则需要自己制作，一般就是自己的各种二维码，这时候我们就需要图床，上传我们的二维码后生成对应的链接，然后在配置到我们的配置文件中：<br>这里提供两个可用图床：</p>
</li>
</ol>
<ul>
<li><a href="https://www.imgurl.org/">imgurl</a>,上传图片大小数量有限制，但是不会压缩图片，可以放二维码、头像等图片。</li>
<li><a href="https://postimages.org/">postimg</a>,上传图片好似没什么限制，但是图片用作博客中时会压缩，分辨率仅有1280px，仅建议本地<code>markdown</code>用户使用。<br><img src="/2022/05/12/blog4/13.png"></li>
</ul>
<h3 id="配置导航菜单栏"><a href="#配置导航菜单栏" class="headerlink" title="配置导航菜单栏"></a>配置导航菜单栏</h3><ol>
<li>导航菜单如下图：<br><img src="/2022/05/12/blog4/14.png"></li>
<li>我们逐一创建对应的菜单文件：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo new page categories   <span class="comment">#分类</span></span><br><span class="line">hexo new page tags         <span class="comment">#标签</span></span><br><span class="line">hexo new page gallery      <span class="comment">#相册</span></span><br></pre></td></tr></table></figure></li>
<li>然后把对应文件夹下的<code>index.md</code>文件中的<code>title</code>改成对应中文：<br><img src="/2022/05/12/blog4/15.png"></li>
<li>接下来我们在配置文件<code>_config.melody.yml</code>中找到menu标签进行修改即可：<br><img src="/2022/05/12/blog4/16.png"></li>
</ol>
<h3 id="配置标签和分类"><a href="#配置标签和分类" class="headerlink" title="配置标签和分类"></a>配置标签和分类</h3><p>我们上一步已经建好了标签和分类的页面，我们只需要在对应的文章头部加上以下字段即可，其中<code>tags、categories</code>就是我们对应页面中<code>index.md</code>中的<code>type</code>：<br><img src="/2022/05/12/blog4/17.png"></p>
<h3 id="发布博客"><a href="#发布博客" class="headerlink" title="发布博客"></a>发布博客</h3><p>后续我们只需要在增加博客文章或者修改博客文章后再执行以下命令即可：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g --d</span><br></pre></td></tr></table></figure>

<h2 id="其他配置"><a href="#其他配置" class="headerlink" title="其他配置"></a>其他配置</h2><h3 id="社交链接配置"><a href="#社交链接配置" class="headerlink" title="社交链接配置"></a>社交链接配置</h3><p>这里我们直接介绍V5版本图标，我们需要访问 <a href="https://fontawesome.com/icons?d=gallery&m=free">font-awesome v5 free icons</a> 去找图标名，前缀有可能是fab、fas等，我们要正常写对前缀才能显示，参考一下图片：<code>图标名 fa+分类首字母 : 网址</code><br><img src="/2022/05/12/blog4/19.png"><br><img src="/2022/05/12/blog4/20.png"><br>同时把配置文件<code>_config.melody.yml</code>中的<code>fontawesomeV5</code>标签的注释取消<br><img src="/2022/05/12/blog4/21.png"></p>
<h3 id="搜索配置"><a href="#搜索配置" class="headerlink" title="搜索配置"></a>搜索配置</h3><p>melody主题提供了两种搜索功能，一个是Algolia，一个是local search。这里推荐使用local search，一是方便且也快速，二是相对简单。Algolia虽也快，但毕竟是国外的，搜索过程中需要初始化一些时间。</p>
<h4 id="algolia设置"><a href="#algolia设置" class="headerlink" title="algolia设置"></a>algolia设置</h4><p>algolia有两种安装，即<a href="https://github.com/oncletom/hexo-algolia">hexo-algolia</a>和<a href="https://github.com/LouisBarranqueiro/hexo-algoliasearch">hexo-algoliasearch</a>，我使用的是后者，其实两者都相差不多。</p>
<ul>
<li>注册搜索API网站</li>
</ul>
<p>**登录<a href="https://www.algolia.com/users/sign_in%EF%BC%8C%E5%8F%AF%E4%BB%A5%E9%80%9A%E8%BF%87github%E5%92%8CGoogle%E8%B4%A6%E5%8F%B7%E7%99%BB%E5%BD%95">https://www.algolia.com/</a>**，可以通过github和Google账号登录<br><img src="/2022/05/12/blog4/22.png"><br>登录后我们在设置中找到API keys,对应的ID、key都是我们需要添加到配置文件中的：<br><img src="/2022/05/12/blog4/23.png"><br><img src="/2022/05/12/blog4/24.png"></p>
<ul>
<li>安装<code>hexo-algoliasearch</code><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install hexo-algoliasearch --save</span><br></pre></td></tr></table></figure></li>
<li>在初始目录下的<code>_config.yml</code>添加<code>hexo-algoliasearch</code>插件和<code>algolia</code>配置，对应的参数上面的API keys中都有<br><img src="/2022/05/12/blog4/25.png"></li>
<li>在配置文件<code>_config.melody.yml</code>下开启algolia:<br><img src="/2022/05/12/blog4/26.png"></li>
<li>部署上algolia，需要将文件的索引上传到algolia，这样才能搜索的到文章标题<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo g   </span><br><span class="line">hexo algolia</span><br></pre></td></tr></table></figure></li>
<li>如果出现报错，则添加HEXO_ALGOLIA_INDEXING_KEY=API Key（你创建的Key）<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export HEXO_ALGOLIA_INDEXING_KEY=API Key  </span><br><span class="line">hexo algolia</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="Local-search设置"><a href="#Local-search设置" class="headerlink" title="Local search设置"></a>Local search设置</h4><p><a href="https://github.com/wzpan/hexo-generator-search">Local search</a>,在本地，所以搜索站点上的标题内容会更加快速</p>
<ul>
<li>安装hexo-generator-search<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install hexo-generator-search --save</span><br></pre></td></tr></table></figure></li>
<li>在初始目录下的<code>_config.yml</code>添加hexo-generator-search参数<br><img src="/2022/05/12/blog4/27.png"></li>
<li>在配置文件<code>_config.melody.yml</code>下开启local search<br><img src="/2022/05/12/blog4/28.png"></li>
<li>然后正常部署即可<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo clean  </span><br><span class="line">hexo g --d</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="评论系统配置"><a href="#评论系统配置" class="headerlink" title="评论系统配置"></a>评论系统配置</h3><p>评论系统我们这里介绍两种<code>Gitalk</code>和<code>Disqus</code></p>
<h4 id="Gitalk配置"><a href="#Gitalk配置" class="headerlink" title="Gitalk配置"></a>Gitalk配置</h4><p>Gitalk部署在GitHub上，通过github Oauth应用的client id和secret值进行连接</p>
<ul>
<li>打开自己的github，进入个人设置，选择Developer settings–&gt;OAuth Apps–&gt;New OAuth APP<br><img src="/2022/05/12/blog4/29.png"><br><img src="/2022/05/12/blog4/30.png"><br><img src="/2022/05/12/blog4/31.png"></li>
<li>在配置文件<code>_config.melody.yml</code>下开启Gitalk：<br><img src="/2022/05/12/blog4/32.png"><br>以上信息都可以在上面创建的<code>## OAuth Apps</code>中找到。</li>
</ul>
<h4 id="Disqus配置"><a href="#Disqus配置" class="headerlink" title="Disqus配置"></a>Disqus配置</h4><ul>
<li>注册评论系统网站：<a href="https://disqus.com/">Disqus官网</a><br><img src="/2022/05/12/blog4/33.png"><br><img src="/2022/05/12/blog4/34.png"></li>
<li>修改自己的昵称（随意，但是要放在hexo的配置文件中）<br><img src="/2022/05/12/blog4/35.png"></li>
<li>在配置文件<code>_config.melody.yml</code>下开启disqus：<br><img src="/2022/05/12/blog4/36.png"></li>
<li>然后重新部署即可：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo clean  </span><br><span class="line">hexo g --d</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="配置文件中其他参数含义"><a href="#配置文件中其他参数含义" class="headerlink" title="配置文件中其他参数含义"></a>配置文件中其他参数含义</h3><p>我用的这个主题主要有两个配置文件，一个是<code>_config.yml</code>,基本配置在这个里面；另一个是<code>_config.melody.yml</code>，主要是除基本配置外的其他配置。</p>
<h4 id="config-yml配置文件"><a href="#config-yml配置文件" class="headerlink" title="_config.yml配置文件"></a><code>_config.yml</code>配置文件</h4><ul>
<li><p>title: 标题</p>
</li>
<li><p>subtitle: 副标题</p>
</li>
<li><p>author: 作者</p>
</li>
<li><p>language: 语言</p>
</li>
<li><p>url: 博客地址</p>
</li>
<li><p>theme: hexo博客主题</p>
</li>
<li><p>deploy模块</p>
</li>
<li><p>search模块</p>
</li>
</ul>
<h4 id="config-melody-yml配置文件"><a href="#config-melody-yml配置文件" class="headerlink" title="_config.melody.yml配置文件"></a><code>_config.melody.yml</code>配置文件</h4><ul>
<li>theme_color:自定义主题色</li>
<li>menu:导航菜单</li>
<li>highlight_theme:代码高亮</li>
<li>code_word_wrap:代码换行</li>
<li>auto_excerpt:自动节选</li>
<li>social:社交</li>
<li>local_search:本地搜索</li>
<li>avatar:头像</li>
<li>top_img:顶部图片</li>
<li>QR_code:文章相关二维码</li>
<li>disqus:disqus评论系统</li>
<li>gitalk:gitalk评论系统</li>
<li>footer_custom_text:页脚自定义文本</li>
<li>links_title:友链</li>
</ul>
]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>博客搭建</tag>
        <tag>hexo</tag>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title>objection+ Wallbreaker基本使用</title>
    <url>/2022/05/13/blog5/</url>
    <content><![CDATA[<h1 id="objection-Wallbreaker基本使用"><a href="#objection-Wallbreaker基本使用" class="headerlink" title="objection+ Wallbreaker基本使用"></a>objection+ Wallbreaker基本使用</h1><table>
<thead>
<tr>
<th>objection 框架</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>objection -g cn.com.ccccaa.ui explore</td>
<td>objection注入指定应用</td>
</tr>
<tr>
<td>android sslpinning disable</td>
<td>过ssl证书认证</td>
</tr>
<tr>
<td>android root disable</td>
<td></td>
</tr>
<tr>
<td>android hooking list activities</td>
<td>查找所有可用activities</td>
</tr>
<tr>
<td>android intent launch_activity 类名</td>
<td>启动指定的类</td>
</tr>
<tr>
<td>android intent launch_service 类名</td>
<td>启动指定服务</td>
</tr>
<tr>
<td>android hooking generate simple 类名</td>
<td>查指定类下面有哪些方法</td>
</tr>
<tr>
<td>android hooking list class_methods 类</td>
<td>列出类的所有方法</td>
</tr>
<tr>
<td>android hooking watch class 类名</td>
<td>监视进行某个操作的时候调用了哪些方法（hook类的所有方法）</td>
</tr>
<tr>
<td>objection -g com.hd.zhibo explore –startup-command “android hooking watch class_method android.app.AlertDialog.onCreate –dump-args –dump-backtrace –dump-return”</td>
<td>hook方法的参数、返回值和调用栈，这种实现方式是启动的时候就hook</td>
</tr>
<tr>
<td>android hooking watch class_method android.app.AlertDialog.onCreate –dump-args –dump-return –dump-backtrace</td>
<td>具体方法调用之前hook</td>
</tr>
<tr>
<td>env</td>
<td>应用环境信息</td>
</tr>
<tr>
<td>ls</td>
<td></td>
</tr>
<tr>
<td>jobs list</td>
<td>创建的Hooks列表</td>
</tr>
<tr>
<td>jobs kill id</td>
<td></td>
</tr>
<tr>
<td>memory list modules</td>
<td>查看内存中加载的库</td>
</tr>
<tr>
<td>memory list exports libssl.so</td>
<td>查看库的导出函数</td>
</tr>
<tr>
<td>memory dump all from_base</td>
<td>提取整个(或部分)内存</td>
</tr>
<tr>
<td>memory dump from_base 0xc935628c 100 memory.dex</td>
<td></td>
</tr>
<tr>
<td>memory search “64 65 78 0a 30 33 35 00”</td>
<td>暴力搜内存</td>
</tr>
<tr>
<td>memory search “aiyou,bucuoo” –string</td>
<td>搜索整个内存</td>
</tr>
<tr>
<td>memory search “aiyou,bucuoo” –string –offsets-only</td>
<td>仅看偏移地址</td>
</tr>
<tr>
<td>android hooking list services</td>
<td>查看可供开启的服务</td>
</tr>
<tr>
<td>android intent launch_service [完整Service名]</td>
<td>直接启动指定service</td>
</tr>
<tr>
<td>android hooking list classes</td>
<td>列出内存中所有的类</td>
</tr>
<tr>
<td>android hooking search classes [display]</td>
<td>在内存中所有已加载的类中搜索包含特定关键词的类</td>
</tr>
<tr>
<td>android hooking search methods [display]</td>
<td>在内存中所有已加载的类的方法中搜索包含特定关键词的类</td>
</tr>
<tr>
<td>cat .objection/objection.log</td>
<td>日志查看</td>
</tr>
<tr>
<td>cat objection.log ｜grep -i http</td>
<td>日志筛选</td>
</tr>
<tr>
<td>objection -g com.android.settings explore -c “2.txt”</td>
<td>运行批量hook</td>
</tr>
<tr>
<td>Wallbreaker</td>
<td></td>
</tr>
<tr>
<td>objection -g com.android.phone explore -P ~/.objection/plugins</td>
<td>使用Wallbreaker</td>
</tr>
<tr>
<td>plugin wallbreaker classsearch <pattern></pattern></td>
<td>搜索类，根据给的 pattern 对所有类名进行匹配，列出匹配到的所有类名</td>
</tr>
<tr>
<td>plugin wallbreaker objectsearch <classname></classname></td>
<td>搜索对象，根据类名搜索内存中已经被创建的实例，列出 handle 和 toString() 的结果。</td>
</tr>
<tr>
<td>plugin wallbreaker classdump <classname> [–fullname]</classname></td>
<td>ClassDump，输出类的结构， 若加了 –fullname 参数，打印的数据中类名会带着完整的包名。</td>
</tr>
<tr>
<td>plugin wallbreaker objectdump <handle> [–fullname]</handle></td>
<td>ObjectDump，在 ClassDump 的基础上，输出指定对象中的每个字段的数据。</td>
</tr>
</tbody></table>
<p><img src="/2022/05/13/blog5/1.png"></p>
<p><img src="/2022/05/13/blog5/2.png"></p>
<p><img src="/2022/05/13/blog5/3.png"></p>
<p><img src="/2022/05/13/blog5/4.png"></p>
]]></content>
      <categories>
        <category>Android攻击手段</category>
      </categories>
      <tags>
        <tag>frida</tag>
        <tag>objection</tag>
        <tag>Wallbreaker</tag>
      </tags>
  </entry>
</search>
